<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¯¸ë¡œ ì°¾ê¸° ê²Œì„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- html2canvas CDN for screenshot functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0; /* Remove body padding, handled by main-layout padding */
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrolling of the entire window */
        }
        .main-layout {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 600px; /* Max width for the whole game area */
            height: calc(100vh - 40px); /* Adjust height to fit viewport, considering body padding */
            box-sizing: border-box;
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* Ensure no scrollbars on the main layout itself */
            padding: 0; /* Remove padding from main-layout, header/footer will have it */
        }
        .game-header {
            height: 70%; /* 70% of main-layout height */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px; /* Inner padding for canvas */
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        .game-footer {
            height: 30%; /* 30% of main-layout height */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px; /* Gap between elements in footer */
            padding: 12px; /* Inner padding for controls */
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent footer from shrinking */
            margin-top: auto; /* Push footer to bottom if space allows */
            overflow-y: auto; /* Allow footer to scroll if its content exceeds 30% */
        }
        canvas {
            border: 2px solid #333;
            background-color: #eee;
            display: block;
            border-radius: 8px;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        .controls-wrapper { /* Wrapper for all controls (directional + rollback) */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Space between canvas and controls row */
            margin-top: 0; /* Managed by footer gap */
            width: 100%; /* Take full width to center content */
        }
        .main-controls-row { /* Container for left rollback, directional, right rollback */
            display: flex;
            align-items: center; /* Vertically center items */
            justify-content: space-between; /* Push rollback groups to edges */
            width: 95%; /* Make it wider to utilize space */
            max-width: 550px; /* Limit max width */
            margin: 0 auto; /* Center the row itself */
            gap: 0; /* Remove gap between groups, space-between handles it */
        }
        .directional-controls {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the rows */
            gap: 5px; /* Space between rows */
            width: 170px; /* Fixed width for the directional block */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .directional-row {
            display: flex;
            justify-content: center;
            gap: 5px; /* Space between buttons in a row */
            width: 100%;
        }
        .directional-row.top-row {
            justify-content: space-between; /* Distribute Q, Up, E */
            align-items: center;
            width: 100%;
            padding: 0 5px; /* Add some padding to prevent Q/E from touching edges */
            box-sizing: border-box;
        }
        .directional-row.middle-row { /* New row for left, down, right */
            justify-content: center; /* Center the buttons */
        }

        /* New base class for common button styles */
        .game-button-base {
            background-color: #FFFFFF;
            color: #000000;
            border-radius: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            padding: 0; /* Remove default padding, set by specific classes */
        }
        .game-button-base:hover {
            background-color: #F0F0F0;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .game-button-base:active {
            background-color: #D0D0D0;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .game-button-base:disabled {
            background-color: #cccccc;
            color: #888888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Specific styles for arrow buttons */
        .arrow-button {
            width: 50px; /* Fixed width */
            height: 50px; /* Fixed height for square shape */
            font-size: 1.8rem; /* Emoji size */
        }

        /* Specific styles for Q and E buttons */
        .special-action-button {
            width: 40px; /* Smaller width */
            height: 40px; /* Smaller height for square shape */
            font-size: 1.5rem; /* Smaller font size */
        }

        .rollback-group {
            display: grid; /* Changed to grid for 2x2 layout */
            grid-template-columns: repeat(2, 1fr); /* 2 columns */
            grid-template-rows: repeat(2, 1fr);    /* 2 rows */
            gap: 5px; /* Space between rollback buttons */
            width: 90px; /* Adjusted width for 2x2 */
            height: 90px; /* Adjusted height for 2x2 */
            align-items: center; /* Center buttons within their group */
            justify-content: center;
        }
        .rollback-button {
            width: 40px; /* Smaller fixed width */
            height: 40px; /* Smaller fixed height */
            border-radius: 8px; /* Slightly more rounded */
            font-size: 0.9rem;
            font-weight: bold;
            color: white; /* Text color for numbers */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: none; /* Remove default button border */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* Added text shadow for visibility */
        }
        .rollback-button:hover {
            transform: scale(1.05); /* Slight scale on hover */
        }
        .rollback-button:active {
            transform: scale(0.95);
        }
        /* Specific colors for rollback buttons (Pastel tones) */
        .rollback-button.red { background-color: #FFB6C1; } /* Pastel Pink */
        .rollback-button.orange { background-color: #FFDAB9; } /* Peach */
        .rollback-button.yellow { background-color: #FFFACD; } /* Lemon Chiffon */
        .rollback-button.green { background-color: #BDECB6; } /* Light Green */

        /* Modified .game-info-container to hold buttons and timer */
        .game-info-container {
            width: 100%;
            display: flex;
            justify-content: center; /* Center items horizontally */
            align-items: center; /* Align items vertically */
            gap: 15px; /* Space between buttons and timer */
            margin-top: 0; /* Managed by footer gap */
        }
        .timer-display {
            font-size: 1.2rem; /* Adjusted timer font size */
            font-weight: bold;
            color: #333;
            background-color: #f0f0f0;
            padding: 8px 16px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .message-box {
            background-color: #FEEBCB;
            color: #9C4221;
            padding: 12px 20px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            display: none;
            width: 100%;
            box-sizing: border-box;
            margin: 0; /* Removed margin, now managed by footer's gap */
        }
        .action-button { /* General style for action buttons */
            background-color: #BDECB6; /* Pastel Green */
            color: white;
            padding: 8px 16px; /* Adjusted padding to match timer */
            border-radius: 12px;
            font-size: 1.1rem; /* Adjusted font size for better fit */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .action-button:hover {
            background-color: #A7D8A0; /* Darker Pastel Green */
            transform: translateY(-2px);
        }
        .action-button:active {
            background-color: #92C38A; /* Even Darker Pastel Green */
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .reset-size-button {
            background-color: #FFB6C1; /* Pastel Pink */
        }
        .reset-size-button:hover {
            background-color: #FF9AA4; /* Darker Pastel Pink */
        }
        .reset-size-button:active {
            background-color: #FF7F8C; /* Even Darker Pastel Pink */
        }

        .help-button {
            background-color: #A7C7E7; /* Pastel Blue */
            color: white;
            padding: 8px 12px; /* Smaller padding for '?' */
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .help-button:hover {
            background-color: #92B4D8;
            transform: translateY(-2px);
        }
        .help-button:active {
            background-color: #7D9CC9;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }


        /* Start Screen Modal Styling */
        .start-screen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .start-screen-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .start-screen-content h2 {
            font-size: 2rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        .maze-size-input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .maze-size-input-group label {
            font-size: 1.1rem;
            color: #555;
        }
        .maze-size-input {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        .maze-size-input input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #ccc;
            border-radius: 8px;
            font-size: 1rem;
            text-align: center;
            -moz-appearance: textfield; /* Firefox hides arrows */
        }
        .maze-size-input input::-webkit-outer-spin-button,
        .maze-size-input input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .size-limit-text {
            font-size: 0.9rem;
            color: #777;
            margin-top: 5px;
        }
        .start-button {
            background-color: #4F46E5;
            color: white;
            padding: 14px 28px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
            margin-top: 10px;
        }
        .start-button:hover {
            background-color: #4338CA;
            transform: translateY(-3px);
        }
        .start-button:active {
            background-color: #3730A3;
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .start-screen-error {
            color: #EF4444; /* Red-500 */
            font-size: 0.9rem;
            margin-top: -10px;
            display: none;
        }

        /* Win Screen Modal Styling */
        .win-modal, .help-modal, .screenshot-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* 50% background blur effect */
            backdrop-filter: blur(5px); /* Optional: add actual blur if supported */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Above start screen modal */
            display: none; /* Hidden by default */
        }
        .win-modal-content, .help-modal-content, .screenshot-modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center; /* Center align content */
            max-width: 90%;
            width: 450px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        .win-message-line { /* For splitting win message into lines */
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 0; /* Remove default paragraph margins */
            line-height: 1.2; /* Adjust line height for better spacing */
        }
        #winEmoji { /* Style for the animated emoji */
            font-size: 6rem; /* Larger emoji */
            animation: bounce 1s infinite alternate; /* Simple bounce animation */
        }
        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-15px); }
        }

        .help-message-title {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }
        .help-message-content {
            font-size: 1rem;
            color: #555;
            text-align: left;
            line-height: 1.5;
        }
        .fireworks-gif { /* This class is now deprecated for the emoji */
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }
        .win-modal-buttons { /* New container for win modal buttons */
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }
        #winRestartButton, #shareButton, #closeHelpModalButton, #closeScreenshotModalButton { /* Combined styles */
            margin-top: 0; /* Managed by parent gap */
            background-color: #A7C7E7; /* Use pastel blue */
            padding: 8px 16px; /* Ensure consistent padding */
            font-size: 1.1rem; /* Ensure consistent font size */
            border-radius: 12px; /* Ensure consistent border-radius */
            flex-grow: 1; /* Allow buttons to grow and share space */
        }
        #winRestartButton:hover, #shareButton:hover, #closeHelpModalButton:hover, #closeScreenshotModalButton:hover {
            background-color: #92B4D8;
        }
        #winRestartButton:active, #shareButton:active, #closeHelpModalButton:active, #closeScreenshotModalButton:active {
            background-color: #7D9CC9;
        }

        /* Screenshot modal specific styles */
        .screenshot-modal-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .screenshot-buttons { /* This class is now deprecated, replaced by win-modal-buttons */
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }

        /* Flash effect overlay */
        .flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            z-index: 3000; /* Above all other modals */
            pointer-events: none; /* Allow clicks to pass through */
        }
        .flash-effect {
            animation: flash 0.3s ease-out forwards;
        }
        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }


        /* Responsive adjustments */
        @media (max-width: 640px) {
            .main-layout {
                padding: 16px;
                height: 100vh; /* Full height on mobile */
            }
            .game-header {
                height: 60%; /* Adjust header height for smaller screens */
            }
            .game-footer {
                height: 40%; /* Adjust footer height for smaller screens */
            }
            .directional-controls {
                width: 120px;
                height: auto; /* Changed to auto for flex layout */
                gap: 3px;
            }
            .arrow-button {
                width: 45px; /* Smaller square buttons on mobile */
                height: 45px;
                font-size: 1.5rem; /* Smaller arrows on smaller screens */
            }
            .special-action-button {
                width: 35px; /* Even smaller Q/E on mobile */
                height: 35px;
                font-size: 1.2rem;
            }
            .action-button {
                padding: 8px 16px; /* Match timer padding */
                font-size: 1rem;
            }
            .timer-display {
                font-size: 1.1rem; /* Slightly smaller timer on mobile */
                padding: 6px 12px;
            }
            .start-screen-content {
                padding: 20px;
                gap: 15px;
            }
            .start-screen-content h2 {
                font-size: 1.7rem;
            }
            .maze-size-input input {
                width: 70px;
                font-size: 0.9rem;
            }
            .start-button {
                padding: 12px 24px;
                font-size: 1.1rem;
            }
            .rollback-button {
                width: 35px; /* Even smaller on mobile */
                height: 35px;
                font-size: 0.8rem;
            }
            .main-controls-row {
                gap: 10px; /* Reduce gap on smaller screens */
            }
            .rollback-group {
                width: 80px; /* Adjust width for smaller rollback buttons */
                height: 80px; /* Adjust height for smaller rollback buttons */
            }
            #winEmoji {
                font-size: 4rem; /* Smaller emoji on mobile */
            }
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Start Screen Modal -->
    <div id="startScreenModal" class="start-screen-modal">
        <div class="start-screen-content">
            <h2>ë¯¸ë¡œ ì°¾ê¸° ê²Œì„</h2>
            <div class="maze-size-input-group">
                <label>ë¯¸ë¡œ í¬ê¸° ì„ íƒ:</label>
                <div id="ageButtonsContainer" class="flex gap-2 flex-wrap justify-center">
                    <button class="action-button age-button" data-size="33">5ì„¸: 33x33</button>
                    <button class="action-button age-button" data-size="45">6ì„¸: 45x45</button>
                    <button class="action-button age-button" data-size="57">7ì„¸: 57x57</button>
                    <button id="customSizeBtn" class="action-button">ì§ì ‘ ì„¤ì •</button>
                </div>
            </div>
            <div id="customSizeContainer" class="maze-size-input-group hidden">
                <label for="mazeWidthSelect">ì§ì ‘ ì„¤ì • (ê°€ë¡œ x ì„¸ë¡œ):</label>
                <div class="maze-size-input">
                    <select id="mazeWidthSelect"></select>
                    <span>x</span>
                    <select id="mazeHeightSelect"></select>
                </div>
                <p class="size-limit-text">í¬ê¸°: 33 ~ 117</p>
                <button id="startButton" class="start-button">ê²Œì„ ì‹œì‘</button>
            </div>
        </div>
    </div>

    <div class="main-layout" style="display: none;"> <!-- Initially hidden -->
        <header class="game-header">
            <canvas id="mazeCanvas"></canvas>
        </header>

        <footer class="game-footer">
            <div class="game-info-container">
                <button id="resetSizeButton" class="action-button reset-size-button">í¬ê¸° ë‹¤ì‹œ ì„¤ì •</button>
                <div id="timer" class="timer-display">00ë¶„00ì´ˆ00</div>
                <button id="restartButton" class="action-button">ë‹¤ì‹œ ì‹œì‘</button>
                <button id="helpButton" class="help-button">?</button>
            </div>

            <div class="message-box" id="messageBox"></div> <!-- Moved here -->

            <div class="controls-wrapper">
                <div class="main-controls-row">
                    <!-- Left Rollback Buttons Group (2x2) -->
                    <div class="rollback-group">
                        <button id="rollback1_left" class="rollback-button red">1</button>
                        <button id="rollback2_left" class="rollback-button orange">2</button>
                        <button id="rollback3_left" class="rollback-button yellow">3</button>
                        <button id="rollback4_left" class="rollback-button green">4</button>
                    </div>

                    <!-- Directional Buttons -->
                    <div class="directional-controls">
                        <div class="directional-row top-row">
                            <button id="qButton" class="game-button-base special-action-button">Q</button>
                            <button id="up" class="game-button-base arrow-button">â¬†ï¸</button>
                            <button id="eButton" class="game-button-base special-action-button">E</button>
                        </div>
                        <div class="directional-row middle-row">
                            <button id="left" class="game-button-base arrow-button">â¬…ï¸</button>
                            <button id="down" class="game-button-base arrow-button">â¬‡ï¸</button>
                            <button id="right" class="game-button-base arrow-button">â¡ï¸</button>
                        </div>
                    </div>

                    <!-- Right Rollback Buttons Group (2x2) -->
                    <div class="rollback-group">
                        <button id="rollback1_right" class="rollback-button red">1</button>
                        <button id="rollback2_right" class="rollback-button orange">2</button>
                        <button id="rollback3_right" class="rollback-button yellow">3</button>
                        <button id="rollback4_right" class="rollback-button green">4</button>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <!-- Win Screen Modal -->
    <div id="winModal" class="win-modal">
        <div class="win-modal-content">
            <p class="win-message-line">ì¶•í•˜í•©ë‹ˆë‹¤!</p>
            <p id="winTimeMessage" class="win-message-line"></p>
            <p id="winMazeSizeMessage" class="win-message-line"></p> <!-- NEW: Maze size message -->
            <span id="winEmoji">ğŸ‰</span> <!-- Animated emoji instead of GIF -->
            <div class="win-modal-buttons"> <!-- New container for buttons -->
                <button id="winRestartButton" class="action-button">ë‹¤ì‹œ ì‹œì‘</button>
                <button id="shareButton" class="action-button">ê³µìœ </button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="help-modal">
        <div class="help-modal-content">
            <p class="help-message-title">ë¯¸ë¡œ ì°¾ê¸° ê²Œì„ ì„¤ëª…</p>
            <p class="help-message-content">
                <strong>ê²Œì„ ëª©í‘œ:</strong> ë§(í”Œë ˆì´ì–´)ì„ ì‹œì‘ ì§€ì (â–¶ï¸)ì—ì„œ ë„ì°© ì§€ì (ğŸš©)ê¹Œì§€ ì´ë™ì‹œì¼œ ë¯¸ë¡œë¥¼ íƒˆì¶œí•˜ì„¸ìš”.<br><br>
                <strong>ì¡°ì‘ë²•:</strong><br>
                - <strong>ì´ë™:</strong> í‚¤ë³´ë“œì˜ í™”ì‚´í‘œ í‚¤(â¬†ï¸â¬‡ï¸â¬…ï¸â¡ï¸) ë˜ëŠ” WASD í‚¤(W:ìœ„, A:ì™¼ìª½, S:ì•„ë˜, D:ì˜¤ë¥¸ìª½)ë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜ í™”ë©´ì˜ ë°©í–¥í‚¤ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”. ë²„íŠ¼ì„ ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ì—°ì† ì´ë™í•©ë‹ˆë‹¤.<br>
                - <strong>Q ë²„íŠ¼:</strong> ì‹œì‘ ì§€ì ìœ¼ë¡œ ì¦‰ì‹œ ì´ë™í•©ë‹ˆë‹¤. ê²Œì„ë‹¹ 1íšŒë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.<br>
                - <strong>E ë²„íŠ¼:</strong> ì§€ë‚˜ì˜¨ ìµœê·¼ 200ì¹¸ì˜ ë¸”ë¡ì„ ëœë¤ ìƒ‰ìƒìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤. ê²Œì„ë‹¹ 1íšŒë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, 0.5ì´ˆë§ˆë‹¤ í•œ ì¹¸ì”© ì‚¬ë¼ì§‘ë‹ˆë‹¤.<br>
                - <strong>ì‹œê°„:</strong> í•˜ë‹¨ì˜ íƒ€ì´ë¨¸ê°€ ë¯¸ë¡œë¥¼ íƒˆì¶œí•˜ëŠ” ë° ê±¸ë¦° ì‹œê°„ì„ ì¸¡ì •í•©ë‹ˆë‹¤.<br><br>
                <strong>ë¡¤ë°± ê¸°ëŠ¥:</strong><br>
                - <strong>ì €ì¥/ì´ë™:</strong> 1, 2, 3, 4ë²ˆ ë¡¤ë°± ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ í˜„ì¬ ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ê±°ë‚˜, ì €ì¥ëœ ìœ„ì¹˜ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>
                - <strong>ì €ì¥ í•´ì œ:</strong> ì €ì¥ëœ ìœ„ì¹˜ë¡œ ì´ë™í•˜ë©´ í•´ë‹¹ ë¡¤ë°± ìœ„ì¹˜ëŠ” ìë™ìœ¼ë¡œ í•´ì œë©ë‹ˆë‹¤.<br><br>
                <strong>ê²Œì„ ê´€ë¦¬:</strong><br>
                - <strong>í¬ê¸° ë‹¤ì‹œ ì„¤ì •:</strong> ìƒˆë¡œìš´ ë¯¸ë¡œ í¬ê¸°ë¥¼ ì„¤ì •í•˜ê³  ê²Œì„ì„ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.<br>
                - <strong>ë‹¤ì‹œ ì‹œì‘:</strong> í˜„ì¬ ë¯¸ë¡œ í¬ê¸°ë¡œ ìƒˆë¡œìš´ ë¯¸ë¡œë¥¼ ìƒì„±í•˜ê³  ê²Œì„ì„ ì¬ì‹œì‘í•©ë‹ˆë‹¤.<br><br>
                <strong>ì‚¬ìš´ë“œ:</strong><br>
                - <strong>ì´ë™:</strong> ë§ì´ ë‹¬ë¦¬ëŠ” ë“¯í•œ ê²½ì¾Œí•œ ì‚¬ìš´ë“œê°€ ì¬ìƒë©ë‹ˆë‹¤.<br>
                - <strong>Q/E/ë¡¤ë°±/ê³µìœ :</strong> ì¬ë¯¸ìˆëŠ” íš¨ê³¼ìŒì´ ì¬ìƒë©ë‹ˆë‹¤.
            </p>
            <button id="closeHelpModalButton" class="action-button">ë‹«ê¸°</button>
        </div>
    </div>

    <!-- Screenshot Display Modal -->
    <div id="screenshotModal" class="screenshot-modal">
        <div class="screenshot-modal-content">
            <h2>ìŠ¤í¬ë¦°ìƒ·</h2>
            <img id="screenshotImage" src="" alt="ê²Œì„ ìŠ¤í¬ë¦°ìƒ·">
            <button id="closeScreenshotModalButton" class="action-button">ë‹«ê¸°</button>
        </div>
    </div>

    <!-- Flash Overlay for screenshot effect -->
    <div id="flashOverlay" class="flash-overlay"></div>

    <script>
        // DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const timerDisplay = document.getElementById('timer');
        const messageBox = document.getElementById('messageBox');
        const restartButton = document.getElementById('restartButton');
        const resetSizeButton = document.getElementById('resetSizeButton');
        const helpButton = document.getElementById('helpButton'); // Help button
        const qButton = document.getElementById('qButton'); // Q button
        const eButton = document.getElementById('eButton'); // E button
        const shareButton = document.getElementById('shareButton'); // Share button

        // ì‹œì‘ í™”ë©´ ìš”ì†Œ
        const startScreenModal = document.getElementById('startScreenModal');
        const mainLayout = document.querySelector('.main-layout');
        const ageButtonsContainer = document.getElementById('ageButtonsContainer');
        const customSizeBtn = document.getElementById('customSizeBtn');
        const customSizeContainer = document.getElementById('customSizeContainer');
        const mazeWidthSelect = document.getElementById('mazeWidthSelect');
        const mazeHeightSelect = document.getElementById('mazeHeightSelect');
        const startButton = document.getElementById('startButton');

        // --- New function to populate dropdowns ---
        function populateSizeDropdowns() {
            mazeWidthSelect.innerHTML = '';
            mazeHeightSelect.innerHTML = '';
            const sizes = [33, 45, 57, 69, 81, 93, 105, 117];
            sizes.forEach(size => {
                const optionWidth = document.createElement('option');
                optionWidth.value = size;
                optionWidth.textContent = `${size}`;
                mazeWidthSelect.appendChild(optionWidth);

                const optionHeight = document.createElement('option');
                optionHeight.value = size;
                optionHeight.textContent = `${size}`;
                mazeHeightSelect.appendChild(optionHeight);
            });
        }

        // --- New function to start the game with specific dimensions ---
        function startGameWithSize(width, height) {
            MAZE_WIDTH = width;
            MAZE_HEIGHT = height;

            startScreenModal.style.display = 'none';
            mainLayout.style.display = 'flex';
            initGame();
        }

        // Event listener for age buttons
        ageButtonsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('age-button')) {
                const size = parseInt(e.target.dataset.size);
                startGameWithSize(size, size);
            }
        });

        // Event listener for "ì§ì ‘ ì„¤ì •" button
        customSizeBtn.addEventListener('click', () => {
            ageButtonsContainer.parentElement.classList.add('hidden'); // Hide age buttons group
            customSizeContainer.classList.remove('hidden'); // Show custom size selectors
        });

        // Event listener for the main start button (now for custom sizes)
        startButton.addEventListener('click', () => {
            const width = parseInt(mazeWidthSelect.value);
            const height = parseInt(mazeHeightSelect.value);
            startGameWithSize(width, height);
        });

        // ë¡¤ë°± ë²„íŠ¼ (ì¢Œì¸¡)
        const rollback1_left = document.getElementById('rollback1_left');
        const rollback2_left = document.getElementById('rollback2_left');
        const rollback3_left = document.getElementById('rollback3_left');
        const rollback4_left = document.getElementById('rollback4_left');

        // ë¡¤ë°± ë²„íŠ¼ (ìš°ì¸¡)
        const rollback1_right = document.getElementById('rollback1_right');
        const rollback2_right = document.getElementById('rollback2_right');
        const rollback3_right = document.getElementById('rollback3_right');
        const rollback4_right = document.getElementById('rollback4_right');

        // ìŠ¹ë¦¬ í™”ë©´ ìš”ì†Œ
        const winModal = document.getElementById('winModal');
        const winTimeMessage = document.getElementById('winTimeMessage'); // New element for time message
        const winMazeSizeMessage = document.getElementById('winMazeSizeMessage'); // NEW: Maze size message element
        const winRestartButton = document.getElementById('winRestartButton');
        const winEmoji = document.getElementById('winEmoji'); // Animated emoji element

        // ë„ì›€ë§ ëª¨ë‹¬ ìš”ì†Œ
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalButton = document.getElementById('closeHelpModalButton');

        // ìŠ¤í¬ë¦°ìƒ· ëª¨ë‹¬ ìš”ì†Œ
        const screenshotModal = document.getElementById('screenshotModal');
        const screenshotImage = document.getElementById('screenshotImage');
        const closeScreenshotModalButton = document.getElementById('closeScreenshotModalButton');
        const flashOverlay = document.getElementById('flashOverlay'); // Flash effect overlay

        // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
        let TILE_SIZE = 40; // Tile size (dynamically calculated)
        let MAZE_WIDTH = 11; // Maze width (set by user input)
        let MAZE_HEIGHT = 11; // Maze height (set by user input)

        let maze = []; // Maze array (dynamically generated)
        let player = { x: 0, y: 0 }; // Player current position (maze grid coordinates)
        let startPos = { x: 0, y: 0 }; // Start position
        let endPos = { x: 0, y: 0 }; // End position

        let startTime; // Timer start time
        let timerInterval; // Timer interval ID
        let gameWon = false; // Game won flag
        let eButtonUsed = false; // E button usage flag
        let qButtonUsed = false; // Q button usage flag (NEW)
        let playerPath = []; // Player movement path storage (max 80 cells)
        const MAX_PLAYER_PATH = 200; // Changed from 80 to 200
        let eButtonClearInterval = null; // Interval for clearing E button path
        let eButtonPathColor = ''; // Random color for E button path

        // Animation variables
        let animationFrameId;
        let flagYOffset = 0;
        let flagAnimationTime = 0;
        const flagFrames = ['ğŸš©']; // Red and Blue flags
        const playerSprite = 'ğŸ'; // Player character sprite

        // Rollback feature saved positions
        let savedPositions = {
            '1': null,
            '2': null,
            '3': null,
            '4': null
        };

        // Variables for continuous mouse movement
        var moveIntervals = {}; // Stores interval IDs for each directional button

        // Tone.js sound settings
        let runningSynth;
        let rollbackSynth;
        let impactSynth;
        let qButtonSynth; // Synth for Q button
        let eButtonSynth; // Synth for E button
        let shutterSynth; // Synth for camera shutter sound
        let audioContextResumed = false;

        // Array of notes for cheerful running sound
        const runningNotes = ["C4", "E4", "G4", "C5"];
        let currentRunningNoteIndex = 0;

        // Function to generate a random transparent RGBA color
        function getRandomTransparentColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            const a = 0.5; // Fixed transparency
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function initAudio() {
            // Running sound: more cheerful and diverse
            runningSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: {
                    type: "triangle" // Brighter sound
                },
                envelope: {
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();

            // Rollback sound: short, higher-pitched chime
            rollbackSynth = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.0,
                    release: 0.2
                }
            }).toDestination();

            // Impact sound for game start
            impactSynth = new Tone.MembraneSynth({
                pitchDecay: 0.08,
                octaves: 1,
                envelope: {
                    attack: 0.001,
                    decay: 0.4,
                    sustain: 0.01,
                    release: 0.6
                },
                oscillator: { type: "sine" }
            }).toDestination();

            // Q button sound: a quick, distinct tone
            qButtonSynth = new Tone.Synth({
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();

            // E button sound: a different quick tone
            eButtonSynth = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: {
                    attack: 0.005,
                    decay: 0.15,
                    sustain: 0.0,
                    release: 0.15
                }
            }).toDestination();

            // Shutter sound for screenshot
            shutterSynth = new Tone.NoiseSynth({
                noise: {
                    type: "white"
                },
                envelope: {
                    attack: 0.001,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();


            // Resume audio context on first user interaction
            document.documentElement.addEventListener('mousedown', () => {
                if (!audioContextResumed) {
                    Tone.start();
                    audioContextResumed = true;
                    console.log("AudioContext resumed!");
                }
            }, { once: true });
        }

        function playRunningSound() {
            if (audioContextResumed) {
                const note = runningNotes[currentRunningNoteIndex];
                runningSynth.triggerAttackRelease(note, "16n"); // Play the current note
                currentRunningNoteIndex = (currentRunningNoteIndex + 1) % runningNotes.length; // Move to the next note
            }
        }

        function playRollbackSound() {
            if (audioContextResumed) {
                rollbackSynth.triggerAttackRelease("G5", "16n"); // Higher note, very short duration
            }
        }

        function playImpactSound() {
            if (audioContextResumed) {
                impactSynth.triggerAttackRelease("C1", "8n"); // Low thump
                setTimeout(() => {
                    impactSynth.triggerAttackRelease("G1", "8n"); // Slightly higher thump
                }, 200);
            }
        }

        function playQButtonSound() {
            if (audioContextResumed) {
                qButtonSynth.triggerAttackRelease("A4", "8n"); // A quick high tone
            }
        }

        function playEButtonSound() {
            if (audioContextResumed) {
                eButtonSynth.triggerAttackRelease("F4", "8n"); // A quick mid tone
            }
        }

        function playShutterSound() {
            if (audioContextResumed) {
                shutterSynth.triggerAttackRelease("8n"); // A short noise burst
            }
        }


        // Function to initialize canvas size based on maze dimensions and available space
        function initializeCanvasSize() {
            const minTileSize = 5; // Minimum readable tile size
            const maxTileSize = 15; // Maximum comfortable tile size

            const headerElement = document.querySelector('.game-header');
            if (!headerElement) {
                console.error("Game header not found!");
                return;
            }

            const headerStyle = window.getComputedStyle(headerElement);
            const headerPaddingLeft = parseFloat(headerStyle.paddingLeft);
            const headerPaddingRight = parseFloat(headerStyle.paddingRight);
            const headerPaddingTop = parseFloat(headerStyle.paddingTop);
            const headerPaddingBottom = parseFloat(headerStyle.paddingBottom);

            const availableWidthForCanvas = headerElement.clientWidth - headerPaddingLeft - headerPaddingRight;
            const availableHeightForCanvas = headerElement.clientHeight - headerPaddingTop - headerPaddingBottom;

            let calculatedTileSizeHeight = Math.floor(availableHeightForCanvas / MAZE_HEIGHT);
            let calculatedTileSizeWidth = Math.floor(availableWidthForCanvas / MAZE_WIDTH);

            TILE_SIZE = Math.min(calculatedTileSizeHeight, calculatedTileSizeWidth);
            TILE_SIZE = Math.max(minTileSize, Math.min(TILE_SIZE, maxTileSize));

            canvas.width = MAZE_WIDTH * TILE_SIZE;
            canvas.height = MAZE_HEIGHT * TILE_SIZE;
        }

        // Function to generate the maze (Recursive Backtracker algorithm)
        function generateMaze() {
            const pathSize = 3;
            const wallSize = 1;
            const step = pathSize + wallSize; // 4

            // Initialize all cells as walls (1 is wall)
            maze = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(1));

            const metaWidth = Math.floor((MAZE_WIDTH - wallSize) / step);
            const metaHeight = Math.floor((MAZE_HEIGHT - wallSize) / step);

            if (metaWidth <= 0 || metaHeight <= 0) {
                console.error("Maze size is too small for this structure.");
                maze = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(0));
                placeStartEnd();
                return;
            }

            let metaVisited = Array(metaHeight).fill(0).map(() => Array(metaWidth).fill(false));
            let stack = [];

            let startMetaX = Math.floor(Math.random() * metaWidth);
            let startMetaY = Math.floor(Math.random() * metaHeight);

            stack.push({ x: startMetaX, y: startMetaY });
            metaVisited[startMetaY][startMetaX] = true;
            
            // Carve the first 3x3 cell
            let startX = wallSize + startMetaX * step;
            let startY = wallSize + startMetaY * step;
            for (let r = 0; r < pathSize; r++) {
                for (let c = 0; c < pathSize; c++) {
                    if (startY + r < MAZE_HEIGHT && startX + c < MAZE_WIDTH) {
                        maze[startY + r][startX + c] = 0;
                    }
                }
            }

            while (stack.length > 0) {
                let current = stack[stack.length - 1];

                let neighbors = [];
                if (current.y > 0 && !metaVisited[current.y - 1][current.x]) neighbors.push({ x: current.x, y: current.y - 1, dir: 'N' });
                if (current.y < metaHeight - 1 && !metaVisited[current.y + 1][current.x]) neighbors.push({ x: current.x, y: current.y + 1, dir: 'S' });
                if (current.x > 0 && !metaVisited[current.y][current.x - 1]) neighbors.push({ x: current.x - 1, y: current.y, dir: 'W' });
                if (current.x < metaWidth - 1 && !metaVisited[current.y][current.x + 1]) neighbors.push({ x: current.x + 1, y: current.y, dir: 'E' });

                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];

                    let currentX = wallSize + current.x * step;
                    let currentY = wallSize + current.y * step;

                    // Carve the wall between current and next
                    if (next.dir === 'N') {
                        for(let i = 0; i < pathSize; i++) maze[currentY - 1][currentX + i] = 0;
                    } else if (next.dir === 'S') {
                        for(let i = 0; i < pathSize; i++) maze[currentY + pathSize][currentX + i] = 0;
                    } else if (next.dir === 'W') {
                        for(let i = 0; i < pathSize; i++) maze[currentY + i][currentX - 1] = 0;
                    } else if (next.dir === 'E') {
                        for(let i = 0; i < pathSize; i++) maze[currentY + i][currentX + pathSize] = 0;
                    }
                    
                    // Carve the 3x3 block for the next cell
                    let nextX = wallSize + next.x * step;
                    let nextY = wallSize + next.y * step;
                     for (let r = 0; r < pathSize; r++) {
                        for (let c = 0; c < pathSize; c++) {
                             if (nextY + r < MAZE_HEIGHT && nextX + c < MAZE_WIDTH) {
                                maze[nextY + r][nextX + c] = 0;
                            }
                        }
                    }

                    metaVisited[next.y][next.x] = true;
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }
            placeStartEnd();
        }

        // Function to randomly place start and end points on paths
        function placeStartEnd() {
            let pathCells = [];
            const pathSize = 3;
            const wallSize = 1;
            const step = pathSize + wallSize; // 4
            const pathCenterOffset = Math.floor(pathSize / 2);

            const metaWidth = Math.floor((MAZE_WIDTH - wallSize) / step);
            const metaHeight = Math.floor((MAZE_HEIGHT - wallSize) / step);

            for (let my = 0; my < metaHeight; my++) {
                for (let mx = 0; mx < metaWidth; mx++) {
                    const centerX = wallSize + mx * step + pathCenterOffset;
                    const centerY = wallSize + my * step + pathCenterOffset;

                    if (maze[centerY]?.[centerX] === 0) {
                        pathCells.push({ x: centerX, y: centerY });
                    }
                }
            }

            if (pathCells.length < 2) {
                console.error("Cannot place start/end, not enough center path cells found. Falling back to any path cell.");
                 // Fallback to any path cell if center cells are not found
                 for (let r = 0; r < MAZE_HEIGHT; r++) {
                    for (let c = 0; c < MAZE_WIDTH; c++) {
                        if (maze[r][c] === 0) {
                            pathCells.push({ x: c, y: r });
                        }
                    }
                }
                 if (pathCells.length < 2) { // If still not enough, hardcode
                    startPos = { x: 1 + pathCenterOffset, y: 1 + pathCenterOffset };
                    endPos = { x: MAZE_WIDTH - 2 - pathCenterOffset, y: MAZE_HEIGHT - 2 - pathCenterOffset };
                    player = { ...startPos };
                    return;
                }
            }

            let startIndex = Math.floor(Math.random() * pathCells.length);
            startPos = pathCells[startIndex];
            player = { ...startPos };
            playerPath = [{ ...player }];

            let endIndex;
            do {
                endIndex = Math.floor(Math.random() * pathCells.length);
            } while (endIndex === startIndex);
            endPos = pathCells[endIndex];
        }

        // Function to draw the maze, player, start, and end points
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            for (let r = 0; r < maze.length; r++) {
                for (let c = 0; c < maze[r].length; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;

                    if (maze[r][c] === 0) {
                        ctx.fillStyle = '#FFFFFF';
                    } else {
                        ctx.fillStyle = '#555555';
                    }
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }

            if (eButtonUsed && playerPath.length > 0) {
                ctx.fillStyle = eButtonPathColor;
                for (let i = 0; i < playerPath.length; i++) {
                    const pathX = playerPath[i].x * TILE_SIZE;
                    const pathY = playerPath[i].y * TILE_SIZE;
                    ctx.fillRect(pathX, pathY, TILE_SIZE, TILE_SIZE);
                }
            }

            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(startPos.x * TILE_SIZE + TILE_SIZE / 2, startPos.y * TILE_SIZE + TILE_SIZE / 2, (TILE_SIZE / 4) * 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = `${TILE_SIZE * 0.4 * 3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('â—', startPos.x * TILE_SIZE + TILE_SIZE / 2, startPos.y * TILE_SIZE + TILE_SIZE / 2);

            ctx.font = `${TILE_SIZE * 0.7 * 3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(flagFrames[0], endPos.x * TILE_SIZE + TILE_SIZE / 2, endPos.y * TILE_SIZE + TILE_SIZE / 2 + flagYOffset);

            ctx.font = `${TILE_SIZE * 0.8 * 3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(playerSprite, player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2);

            for (const key in savedPositions) {
                const pos = savedPositions[key];
                if (pos) {
                    ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
                    ctx.beginPath();
                    ctx.arc(pos.x * TILE_SIZE + TILE_SIZE / 2, pos.y * TILE_SIZE + TILE_SIZE / 2, (TILE_SIZE / 2.5) * 3, 0, Math.PI * 2);
                    ctx.fill();

                    switch (key) {
                        case '1': ctx.fillStyle = 'red'; break;
                        case '2': ctx.fillStyle = 'orange'; break;
                        case '3': ctx.fillStyle = 'yellow'; break;
                        case '4': ctx.fillStyle = 'green'; break;
                        default: ctx.fillStyle = 'white';
                    }

                    ctx.font = `${TILE_SIZE * 0.6 * 3}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(key, pos.x * TILE_SIZE + TILE_SIZE / 2, pos.y * TILE_SIZE + TILE_SIZE / 2);
                }
            }
        }

        // --- Animation Loop ---
        function animate() {
            if (gameWon) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const animationSpeed = 0.05;
            flagAnimationTime += animationSpeed;
            flagYOffset = Math.sin(flagAnimationTime) * (TILE_SIZE * 0.15);

            drawMaze();
            animationFrameId = requestAnimationFrame(animate);
        }

        // Function to move the player
        function movePlayer(dx, dy) {
            if (gameWon) return;
            
            const pathSize = 3;
            const wallSize = 1;
            const step = pathSize + wallSize; // 4
            const pathCenterOffset = Math.floor(pathSize / 2); // 1

            // Calculate the wall cell to check
            const wallCheckX = player.x + dx * (pathCenterOffset + wallSize);
            const wallCheckY = player.y + dy * (pathCenterOffset + wallSize);

            // Check boundaries for the wall cell
            if (wallCheckX < 0 || wallCheckX >= MAZE_WIDTH || wallCheckY < 0 || wallCheckY >= MAZE_HEIGHT) {
                return;
            }

            // Check if the wall cell is a path (i.e., has been carved)
            if (maze[wallCheckY]?.[wallCheckX] === 0) {
                const newX = player.x + dx * step;
                const newY = player.y + dy * step;
                
                player.x = newX;
                player.y = newY;

                if (!eButtonUsed) {
                    playerPath.push({ x: player.x, y: player.y });
                    if (playerPath.length > MAX_PLAYER_PATH) {
                        playerPath.shift();
                    }
                }

                drawMaze();
                checkWin();
                playRunningSound();
            }
        }

        // Function to update timer display
        function updateTimerDisplay() {
            const elapsedTimeMs = Date.now() - startTime;
            const minutes = String(Math.floor(elapsedTimeMs / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((elapsedTimeMs % 60000) / 1000)).padStart(2, '0');
            const milliseconds = String(Math.floor((elapsedTimeMs % 1000) / 10)).padStart(2, '0');
            timerDisplay.textContent = `${minutes}ë¶„${seconds}ì´ˆ${milliseconds}`;
        }

        // Function to start the timer
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 10);
        }

        // Function to stop the timer
        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Function to display messages to the user
        function showMessage(message, type = 'info') {
            if (messageBox) {
                messageBox.textContent = message;
                messageBox.style.display = 'block';
                if (type === 'win') {
                    messageBox.className = 'message-box bg-green-200 text-green-800';
                } else if (type === 'error') {
                    messageBox.className = 'message-box bg-red-200 text-red-800';
                } else {
                    messageBox.className = 'message-box bg-yellow-200 text-yellow-800';
                }
            } else {
                console.error("messageBox element not found!");
            }
        }

        // Function to hide the message box
        function hideMessage() {
            if (messageBox) {
                messageBox.style.display = 'none';
            } else {
                console.error("messageBox element to hide not found!");
            }
        }

        // Function to check if the player has reached the end
        function checkWin() {
            if (player.x === endPos.x && player.y === endPos.y) {
                stopTimer();
                gameWon = true;
                winTimeMessage.textContent = `ì‹œê°„: ${timerDisplay.textContent}`;
                winMazeSizeMessage.textContent = `í´ë¦¬ì–´í•œ ë¯¸ë¡œ í¬ê¸°: ${MAZE_WIDTH} x ${MAZE_HEIGHT}`;
                winModal.style.display = 'flex';
            }
        }

        // Function to save or load position
        function saveOrLoadPosition(key) {
            if (gameWon) return;

            const currentPos = { x: player.x, y: player.y };
            const savedPos = savedPositions[key];

            if (savedPos && currentPos.x === savedPos.x && currentPos.y === savedPos.y) {
                savedPositions[key] = null;
                showMessage(`${key}ë²ˆ ìœ„ì¹˜ ì €ì¥ í•´ì œë¨.`);
            }
            else if (savedPos) {
                player.x = savedPos.x;
                player.y = savedPos.y;
                savedPositions[key] = null;
                showMessage(`${key}ë²ˆ ìœ„ì¹˜ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤. ì €ì¥ëœ ìœ„ì¹˜ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                checkWin();
            }
            else {
                savedPositions[key] = { ...currentPos };
                showMessage(`${key}ë²ˆ ìœ„ì¹˜ì— í˜„ì¬ ìœ„ì¹˜ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤.`);
            }
            drawMaze();
            playRollbackSound();
        }

        // Function to take screenshot and display it
        async function takeScreenshot() {
            playShutterSound();
            flashOverlay.classList.add('flash-effect');
            setTimeout(() => {
                flashOverlay.classList.remove('flash-effect');
            }, 300);

            try {
                const canvasElement = await html2canvas(mainLayout);
                const imageDataUrl = canvasElement.toDataURL('image/png');

                if (navigator.clipboard && navigator.clipboard.write) {
                    try {
                        const response = await fetch(imageDataUrl);
                        const blob = await response.blob();
                        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                        showMessage('ìŠ¤í¬ë¦°ìƒ·ì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!', 'info');
                    } catch (clipboardError) {
                        console.error('í´ë¦½ë³´ë“œ ë³µì‚¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (navigator.clipboard.write):', clipboardError);
                        const tempInput = document.createElement('textarea');
                        tempInput.value = imageDataUrl;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        try {
                            document.execCommand('copy');
                            showMessage('ìŠ¤í¬ë¦°ìƒ· ë°ì´í„° URLì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤. (ì´ë¯¸ì§€ ì§ì ‘ ë³µì‚¬ ë¶ˆê°€)', 'info');
                        } catch (execCommandError) {
                            console.error('execCommand("copy") ì‹¤íŒ¨:', execCommandError);
                            showMessage('í´ë¦½ë³´ë“œ ë³µì‚¬ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'error');
                        } finally {
                            document.body.removeChild(tempInput);
                        }
                    }
                } else {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = imageDataUrl;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        document.execCommand('copy');
                        showMessage('ìŠ¤í¬ë¦°ìƒ· ë°ì´í„° URLì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤. (ì´ë¯¸ì§€ ì§ì ‘ ë³µì‚¬ ë¶ˆê°€)', 'info');
                    } catch (execCommandError) {
                        console.error('execCommand("copy") ì‹¤íŒ¨:', execCommandError);
                        showMessage('í´ë¦½ë³´ë“œ ë³µì‚¬ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'error');
                    } finally {
                        document.body.removeChild(tempInput);
                    }
                }

                screenshotImage.src = imageDataUrl;
                screenshotModal.style.display = 'flex';

            } catch (err) {
                console.error('ìŠ¤í¬ë¦°ìƒ·ì„ ìƒì„±í•˜ê±°ë‚˜ ë³µì‚¬í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', err);
                showMessage('ìŠ¤í¬ë¦°ìƒ· ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
            }
        }


        // Function to initialize the game
        function initGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            hideMessage();
            winModal.style.display = 'none';
            helpModal.style.display = 'none';
            screenshotModal.style.display = 'none';
            gameWon = false;
            
            eButtonUsed = false;
            eButton.disabled = false;
            eButton.classList.remove('disabled');
            if (eButtonClearInterval) {
                clearInterval(eButtonClearInterval);
                eButtonClearInterval = null;
            }
            eButtonPathColor = getRandomTransparentColor();

            qButtonUsed = false;
            qButton.disabled = false;
            qButton.classList.remove('disabled');
            
            stopTimer();
            timerDisplay.textContent = '00ë¶„00ì´ˆ00';
            for (let key in savedPositions) {
                savedPositions[key] = null;
            }

            initializeCanvasSize();
            generateMaze();
            playImpactSound();
            
            animate();
            startTimer();
        }

        // Function to show the start screen
        function showStartScreen() {
            startScreenModal.style.display = 'flex';
            mainLayout.style.display = 'none';
            winModal.style.display = 'none';
            helpModal.style.display = 'none';
            screenshotModal.style.display = 'none';

            ageButtonsContainer.parentElement.classList.remove('hidden');
            customSizeContainer.classList.add('hidden');
        }

        function startContinuousMove(direction) {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex') return;
            if (moveIntervals[direction]) return;

            const moveMap = {
                'up': () => movePlayer(0, -1),
                'down': () => movePlayer(0, 1),
                'left': () => movePlayer(-1, 0),
                'right': () => movePlayer(1, 0)
            };

            moveMap[direction]();
            moveIntervals[direction] = setInterval(moveMap[direction], 150);
        }

        function stopContinuousMove(direction) {
            if (moveIntervals[direction]) {
                clearInterval(moveIntervals[direction]);
                delete moveIntervals[direction];
            }
        }

        document.addEventListener('keydown', (e) => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex') return;

            if (['1', '2', '3', '4'].includes(e.key)) {
                saveOrLoadPosition(e.key);
                return;
            }

            if ((e.key === 'q' || e.key === 'Q') && !qButtonUsed) {
                qButtonUsed = true;
                qButton.disabled = true;
                qButton.classList.add('disabled');
                playQButtonSound();
                player.x = startPos.x;
                player.y = startPos.y;
                playerPath = [{ ...player }];
                drawMaze();
                showMessage("Q ë²„íŠ¼ì€ ê²Œì„ë‹¹ 1íšŒë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. ì‹œì‘ ì§€ì ìœ¼ë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.");
                return;
            }

            if ((e.key === 'e' || e.key === 'E') && !eButtonUsed) {
                eButtonUsed = true;
                eButton.disabled = true;
                eButton.classList.add('disabled');
                playEButtonSound();
                showMessage(`ìµœê·¼ ì´ë™ ê²½ë¡œ ${MAX_PLAYER_PATH}ì¹¸ì„ í‘œì‹œí•©ë‹ˆë‹¤. 0.5ì´ˆë§ˆë‹¤ ì‚¬ë¼ì§‘ë‹ˆë‹¤.`);
                drawMaze();

                eButtonClearInterval = setInterval(() => {
                    if (playerPath.length > 0) {
                        playerPath.shift();
                        drawMaze();
                    } else {
                        clearInterval(eButtonClearInterval);
                        eButtonClearInterval = null;
                        showMessage("ì´ë™ ê²½ë¡œ í‘œì‹œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.", 'info');
                    }
                }, 500);

                return;
            }

            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W': movePlayer(0, -1); break;
                case 'ArrowDown': case 's': case 'S': movePlayer(0, 1); break;
                case 'ArrowLeft': case 'a': case 'A': movePlayer(-1, 0); break;
                case 'ArrowRight': case 'd': case 'D': movePlayer(1, 0); break;
            }
        });

        document.getElementById('up').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('up'); });
        document.getElementById('down').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('down'); });
        document.getElementById('left').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('left'); });
        document.getElementById('right').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('right'); });

        qButton.addEventListener('click', () => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex' || qButtonUsed) return;
            qButtonUsed = true;
            qButton.disabled = true;
            qButton.classList.add('disabled');
            playQButtonSound();
            player.x = startPos.x;
            player.y = startPos.y;
            playerPath = [{ ...player }];
            drawMaze();
            showMessage("Q ë²„íŠ¼ì€ ê²Œì„ë‹¹ 1íšŒë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. ì‹œì‘ ì§€ì ìœ¼ë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.");
        });

        eButton.addEventListener('click', () => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex' || eButtonUsed) return;
            eButtonUsed = true;
            eButton.disabled = true;
            eButton.classList.add('disabled');
            playEButtonSound();
            showMessage(`ìµœê·¼ ì´ë™ ê²½ë¡œ ${MAX_PLAYER_PATH}ì¹¸ì„ í‘œì‹œí•©ë‹ˆë‹¤. 0.5ì´ˆë§ˆë‹¤ ì‚¬ë¼ì§‘ë‹ˆë‹¤.`);
            drawMaze();

            eButtonClearInterval = setInterval(() => {
                if (playerPath.length > 0) {
                    playerPath.shift();
                    drawMaze();
                } else {
                    clearInterval(eButtonClearInterval);
                    eButtonClearInterval = null;
                    showMessage("ì´ë™ ê²½ë¡œ í‘œì‹œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.", 'info');
                }
            }, 500);
        });

        shareButton.addEventListener('click', takeScreenshot);
        closeScreenshotModalButton.addEventListener('click', () => {
            screenshotModal.style.display = 'none';
        });

        document.addEventListener('mouseup', () => {
            for (const dir in moveIntervals) {
                stopContinuousMove(dir);
            }
        });

        document.getElementById('up').addEventListener('mouseleave', () => stopContinuousMove('up'));
        document.getElementById('down').addEventListener('mouseleave', () => stopContinuousMove('down'));
        document.getElementById('left').addEventListener('mouseleave', () => stopContinuousMove('left'));
        document.getElementById('right').addEventListener('mouseleave', () => stopContinuousMove('right'));
        qButton.addEventListener('mouseleave', () => stopContinuousMove('q'));
        eButton.addEventListener('mouseleave', () => stopContinuousMove('e'));

        rollback1_left.addEventListener('click', () => saveOrLoadPosition('1'));
        rollback2_left.addEventListener('click', () => saveOrLoadPosition('2'));
        rollback3_left.addEventListener('click', () => saveOrLoadPosition('3'));
        rollback4_left.addEventListener('click', () => saveOrLoadPosition('4'));

        rollback1_right.addEventListener('click', () => saveOrLoadPosition('1'));
        rollback2_right.addEventListener('click', () => saveOrLoadPosition('2'));
        rollback3_right.addEventListener('click', () => saveOrLoadPosition('3'));
        rollback4_right.addEventListener('click', () => saveOrLoadPosition('4'));

        restartButton.addEventListener('click', initGame);
        winRestartButton.addEventListener('click', () => {
            winModal.style.display = 'none';
            initGame();
        });

        resetSizeButton.addEventListener('click', showStartScreen);
        helpButton.addEventListener('click', () => {
            helpModal.style.display = 'flex';
        });
        closeHelpModalButton.addEventListener('click', () => {
            helpModal.style.display = 'none';
        });

        window.addEventListener('resize', () => {
            if (mainLayout.style.display === 'flex') {
                initGame();
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            populateSizeDropdowns();
            showStartScreen();
            initAudio();
        });
    </script>
</body>
</html>
