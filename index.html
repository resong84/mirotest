<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>미로 찾기 게임</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- html2canvas CDN for screenshot functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0; /* Remove body padding, handled by main-layout padding */
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrolling of the entire window */
        }
        .main-layout {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 600px; /* Max width for the whole game area */
            height: calc(100vh - 40px); /* Adjust height to fit viewport, considering body padding */
            box-sizing: border-box;
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* Ensure no scrollbars on the main layout itself */
            padding: 0; /* Remove padding from main-layout, header/footer will have it */
        }
        .game-header {
            height: 70%; /* 70% of main-layout height */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px; /* Inner padding for canvas */
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        .game-footer {
            height: 30%; /* 30% of main-layout height */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px; /* Gap between elements in footer */
            padding: 12px; /* Inner padding for controls */
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent footer from shrinking */
            margin-top: auto; /* Push footer to bottom if space allows */
            overflow-y: auto; /* Allow footer to scroll if its content exceeds 30% */
        }
        canvas {
            border: 2px solid #333;
            background-color: #eee;
            display: block;
            border-radius: 8px;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        .controls-wrapper { /* Wrapper for all controls (directional + rollback) */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Space between canvas and controls row */
            margin-top: 0; /* Managed by footer gap */
            width: 100%; /* Take full width to center content */
        }
        .main-controls-row { /* Container for left rollback, directional, right rollback */
            display: flex;
            align-items: center; /* Vertically center items */
            justify-content: space-between; /* Push rollback groups to edges */
            width: 95%; /* Make it wider to utilize space */
            max-width: 550px; /* Limit max width */
            margin: 0 auto; /* Center the row itself */
            gap: 0; /* Remove gap between groups, space-between handles it */
        }
        .directional-controls {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the rows */
            gap: 5px; /* Space between rows */
            width: 170px; /* Fixed width for the directional block */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .directional-row {
            display: flex;
            justify-content: center;
            gap: 5px; /* Space between buttons in a row */
            width: 100%;
        }
        .directional-row.top-row {
            justify-content: space-between; /* Distribute Q, Up, E */
            align-items: center;
            width: 100%;
            padding: 0 5px; /* Add some padding to prevent Q/E from touching edges */
            box-sizing: border-box;
        }
        .directional-row.middle-row { /* New row for left, down, right */
            justify-content: center; /* Center the buttons */
        }

        /* New base class for common button styles */
        .game-button-base {
            background-color: #FFFFFF;
            color: #000000;
            border-radius: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            padding: 0; /* Remove default padding, set by specific classes */
        }
        .game-button-base:hover {
            background-color: #F0F0F0;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .game-button-base:active {
            background-color: #D0D0D0;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .game-button-base:disabled {
            background-color: #cccccc;
            color: #888888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Specific styles for arrow buttons */
        .arrow-button {
            width: 50px; /* Fixed width */
            height: 50px; /* Fixed height for square shape */
            font-size: 1.8rem; /* Emoji size */
        }

        /* Specific styles for Q and E buttons */
        .special-action-button {
            width: 40px; /* Smaller width */
            height: 40px; /* Smaller height for square shape */
            font-size: 1.5rem; /* Smaller font size */
        }

        .rollback-group {
            display: grid; /* Changed to grid for 2x2 layout */
            grid-template-columns: repeat(2, 1fr); /* 2 columns */
            grid-template-rows: repeat(2, 1fr);    /* 2 rows */
            gap: 5px; /* Space between rollback buttons */
            width: 90px; /* Adjusted width for 2x2 */
            height: 90px; /* Adjusted height for 2x2 */
            align-items: center; /* Center buttons within their group */
            justify-content: center;
        }
        .rollback-button {
            width: 40px; /* Smaller fixed width */
            height: 40px; /* Smaller fixed height */
            border-radius: 8px; /* Slightly more rounded */
            font-size: 0.9rem;
            font-weight: bold;
            color: white; /* Text color for numbers */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: none; /* Remove default button border */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* Added text shadow for visibility */
        }
        .rollback-button:hover {
            transform: scale(1.05); /* Slight scale on hover */
        }
        .rollback-button:active {
            transform: scale(0.95);
        }
        /* Specific colors for rollback buttons (Pastel tones) */
        .rollback-button.red { background-color: #FFB6C1; } /* Pastel Pink */
        .rollback-button.orange { background-color: #FFDAB9; } /* Peach */
        .rollback-button.yellow { background-color: #FFFACD; } /* Lemon Chiffon */
        .rollback-button.green { background-color: #BDECB6; } /* Light Green */

        /* Modified .game-info-container to hold buttons and timer */
        .game-info-container {
            width: 100%;
            display: flex;
            justify-content: center; /* Center items horizontally */
            align-items: center; /* Align items vertically */
            gap: 15px; /* Space between buttons and timer */
            margin-top: 0; /* Managed by footer gap */
        }
        .timer-display {
            font-size: 1.2rem; /* Adjusted timer font size */
            font-weight: bold;
            color: #333;
            background-color: #f0f0f0;
            padding: 8px 16px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .message-box {
            background-color: #FEEBCB;
            color: #9C4221;
            padding: 12px 20px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            display: none;
            width: 100%;
            box-sizing: border-box;
            margin: 0; /* Removed margin, now managed by footer's gap */
        }
        .action-button { /* General style for action buttons */
            background-color: #BDECB6; /* Pastel Green */
            color: white;
            padding: 8px 16px; /* Adjusted padding to match timer */
            border-radius: 12px;
            font-size: 1.1rem; /* Adjusted font size for better fit */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .action-button:hover {
            background-color: #A7D8A0; /* Darker Pastel Green */
            transform: translateY(-2px);
        }
        .action-button:active {
            background-color: #92C38A; /* Even Darker Pastel Green */
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .reset-size-button {
            background-color: #FFB6C1; /* Pastel Pink */
        }
        .reset-size-button:hover {
            background-color: #FF9AA4; /* Darker Pastel Pink */
        }
        .reset-size-button:active {
            background-color: #FF7F8C; /* Even Darker Pastel Pink */
        }

        .help-button {
            background-color: #A7C7E7; /* Pastel Blue */
            color: white;
            padding: 8px 12px; /* Smaller padding for '?' */
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .help-button:hover {
            background-color: #92B4D8;
            transform: translateY(-2px);
        }
        .help-button:active {
            background-color: #7D9CC9;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }


        /* Start Screen Modal Styling */
        .start-screen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .start-screen-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .start-screen-content h2 {
            font-size: 2rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        .maze-size-input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .maze-size-input-group label {
            font-size: 1.1rem;
            color: #555;
        }
        .maze-size-input {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        .maze-size-input input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #ccc;
            border-radius: 8px;
            font-size: 1rem;
            text-align: center;
            -moz-appearance: textfield; /* Firefox hides arrows */
        }
        .maze-size-input input::-webkit-outer-spin-button,
        .maze-size-input input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .size-limit-text {
            font-size: 0.9rem;
            color: #777;
            margin-top: 5px;
        }
        .start-button {
            background-color: #4F46E5;
            color: white;
            padding: 14px 28px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
            margin-top: 10px;
        }
        .start-button:hover {
            background-color: #4338CA;
            transform: translateY(-3px);
        }
        .start-button:active {
            background-color: #3730A3;
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .start-screen-error {
            color: #EF4444; /* Red-500 */
            font-size: 0.9rem;
            margin-top: -10px;
            display: none;
        }

        /* Win Screen Modal Styling */
        .win-modal, .help-modal, .screenshot-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* 50% background blur effect */
            backdrop-filter: blur(5px); /* Optional: add actual blur if supported */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Above start screen modal */
            display: none; /* Hidden by default */
        }
        .win-modal-content, .help-modal-content, .screenshot-modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center; /* Center align content */
            max-width: 90%;
            width: 450px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        .win-message-line { /* For splitting win message into lines */
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 0; /* Remove default paragraph margins */
            line-height: 1.2; /* Adjust line height for better spacing */
        }
        #winEmoji { /* Style for the animated emoji */
            font-size: 6rem; /* Larger emoji */
            animation: bounce 1s infinite alternate; /* Simple bounce animation */
        }
        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-15px); }
        }

        .help-message-title {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }
        .help-message-content {
            font-size: 1rem;
            color: #555;
            text-align: left;
            line-height: 1.5;
        }
        .fireworks-gif { /* This class is now deprecated for the emoji */
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }
        .win-modal-buttons { /* New container for win modal buttons */
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }
        #winRestartButton, #shareButton, #closeHelpModalButton, #closeScreenshotModalButton { /* Combined styles */
            margin-top: 0; /* Managed by parent gap */
            background-color: #A7C7E7; /* Use pastel blue */
            padding: 8px 16px; /* Ensure consistent padding */
            font-size: 1.1rem; /* Ensure consistent font size */
            border-radius: 12px; /* Ensure consistent border-radius */
            flex-grow: 1; /* Allow buttons to grow and share space */
        }
        #winRestartButton:hover, #shareButton:hover, #closeHelpModalButton:hover, #closeScreenshotModalButton:hover {
            background-color: #92B4D8;
        }
        #winRestartButton:active, #shareButton:active, #closeHelpModalButton:active, #closeScreenshotModalButton:active {
            background-color: #7D9CC9;
        }

        /* Screenshot modal specific styles */
        .screenshot-modal-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .screenshot-buttons { /* This class is now deprecated, replaced by win-modal-buttons */
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }

        /* Flash effect overlay */
        .flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            z-index: 3000; /* Above all other modals */
            pointer-events: none; /* Allow clicks to pass through */
        }
        .flash-effect {
            animation: flash 0.3s ease-out forwards;
        }
        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }


        /* Responsive adjustments */
        @media (max-width: 640px) {
            .main-layout {
                padding: 16px;
                height: 100vh; /* Full height on mobile */
            }
            .game-header {
                height: 60%; /* Adjust header height for smaller screens */
            }
            .game-footer {
                height: 40%; /* Adjust footer height for smaller screens */
            }
            .directional-controls {
                width: 120px;
                height: auto; /* Changed to auto for flex layout */
                gap: 3px;
            }
            .arrow-button {
                width: 45px; /* Smaller square buttons on mobile */
                height: 45px;
                font-size: 1.5rem; /* Smaller arrows on smaller screens */
            }
            .special-action-button {
                width: 35px; /* Even smaller Q/E on mobile */
                height: 35px;
                font-size: 1.2rem;
            }
            .action-button {
                padding: 8px 16px; /* Match timer padding */
                font-size: 1rem;
            }
            .timer-display {
                font-size: 1.1rem; /* Slightly smaller timer on mobile */
                padding: 6px 12px;
            }
            .start-screen-content {
                padding: 20px;
                gap: 15px;
            }
            .start-screen-content h2 {
                font-size: 1.7rem;
            }
            .maze-size-input input {
                width: 70px;
                font-size: 0.9rem;
            }
            .start-button {
                padding: 12px 24px;
                font-size: 1.1rem;
            }
            .rollback-button {
                width: 35px; /* Even smaller on mobile */
                height: 35px;
                font-size: 0.8rem;
            }
            .main-controls-row {
                gap: 10px; /* Reduce gap on smaller screens */
            }
            .rollback-group {
                width: 80px; /* Adjust width for smaller rollback buttons */
                height: 80px; /* Adjust height for smaller rollback buttons */
            }
            #winEmoji {
                font-size: 4rem; /* Smaller emoji on mobile */
            }
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Start Screen Modal -->
    <div id="startScreenModal" class="start-screen-modal">
        <div class="start-screen-content">
            <h2>미로 찾기 게임</h2>
            <div class="maze-size-input-group">
                <label>미로 크기 선택:</label>
                <div id="ageButtonsContainer" class="flex gap-2 flex-wrap justify-center">
                    <button class="action-button age-button" data-size="33">5세: 33x33</button>
                    <button class="action-button age-button" data-size="45">6세: 45x45</button>
                    <button class="action-button age-button" data-size="57">7세: 57x57</button>
                    <button id="customSizeBtn" class="action-button">직접 설정</button>
                </div>
            </div>
            <div id="customSizeContainer" class="maze-size-input-group hidden">
                <label for="mazeWidthSelect">직접 설정 (가로 x 세로):</label>
                <div class="maze-size-input">
                    <select id="mazeWidthSelect"></select>
                    <span>x</span>
                    <select id="mazeHeightSelect"></select>
                </div>
                <p class="size-limit-text">크기: 33 ~ 117</p>
                <button id="startButton" class="start-button">게임 시작</button>
            </div>
        </div>
    </div>

    <div class="main-layout" style="display: none;"> <!-- Initially hidden -->
        <header class="game-header">
            <canvas id="mazeCanvas"></canvas>
        </header>

        <footer class="game-footer">
            <div class="game-info-container">
                <button id="resetSizeButton" class="action-button reset-size-button">크기 다시 설정</button>
                <div id="timer" class="timer-display">00분00초00</div>
                <button id="restartButton" class="action-button">다시 시작</button>
                <button id="helpButton" class="help-button">?</button>
            </div>

            <div class="message-box" id="messageBox"></div> <!-- Moved here -->

            <div class="controls-wrapper">
                <div class="main-controls-row">
                    <!-- Left Rollback Buttons Group (2x2) -->
                    <div class="rollback-group">
                        <button id="rollback1_left" class="rollback-button red">1</button>
                        <button id="rollback2_left" class="rollback-button orange">2</button>
                        <button id="rollback3_left" class="rollback-button yellow">3</button>
                        <button id="rollback4_left" class="rollback-button green">4</button>
                    </div>

                    <!-- Directional Buttons -->
                    <div class="directional-controls">
                        <div class="directional-row top-row">
                            <button id="qButton" class="game-button-base special-action-button">Q</button>
                            <button id="up" class="game-button-base arrow-button">⬆️</button>
                            <button id="eButton" class="game-button-base special-action-button">E</button>
                        </div>
                        <div class="directional-row middle-row">
                            <button id="left" class="game-button-base arrow-button">⬅️</button>
                            <button id="down" class="game-button-base arrow-button">⬇️</button>
                            <button id="right" class="game-button-base arrow-button">➡️</button>
                        </div>
                    </div>

                    <!-- Right Rollback Buttons Group (2x2) -->
                    <div class="rollback-group">
                        <button id="rollback1_right" class="rollback-button red">1</button>
                        <button id="rollback2_right" class="rollback-button orange">2</button>
                        <button id="rollback3_right" class="rollback-button yellow">3</button>
                        <button id="rollback4_right" class="rollback-button green">4</button>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <!-- Win Screen Modal -->
    <div id="winModal" class="win-modal">
        <div class="win-modal-content">
            <p class="win-message-line">축하합니다!</p>
            <p id="winTimeMessage" class="win-message-line"></p>
            <p id="winMazeSizeMessage" class="win-message-line"></p> <!-- NEW: Maze size message -->
            <span id="winEmoji">🎉</span> <!-- Animated emoji instead of GIF -->
            <div class="win-modal-buttons"> <!-- New container for buttons -->
                <button id="winRestartButton" class="action-button">다시 시작</button>
                <button id="shareButton" class="action-button">공유</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="help-modal">
        <div class="help-modal-content">
            <p class="help-message-title">미로 찾기 게임 설명</p>
            <p class="help-message-content">
                <strong>게임 목표:</strong> 말(플레이어)을 시작 지점(▶️)에서 도착 지점(🚩)까지 이동시켜 미로를 탈출하세요.<br><br>
                <strong>조작법:</strong><br>
                - <strong>이동:</strong> 키보드의 화살표 키(⬆️⬇️⬅️➡️) 또는 WASD 키(W:위, A:왼쪽, S:아래, D:오른쪽)를 사용하거나 화면의 방향키 버튼을 클릭하세요. 버튼을 누르고 있으면 연속 이동합니다.<br>
                - <strong>Q 버튼:</strong> 시작 지점으로 즉시 이동합니다. 게임당 1회만 사용 가능합니다.<br>
                - <strong>E 버튼:</strong> 지나온 최근 200칸의 블록을 랜덤 색상으로 표시합니다. 게임당 1회만 사용 가능하며, 0.5초마다 한 칸씩 사라집니다.<br>
                - <strong>시간:</strong> 하단의 타이머가 미로를 탈출하는 데 걸린 시간을 측정합니다.<br><br>
                <strong>롤백 기능:</strong><br>
                - <strong>저장/이동:</strong> 1, 2, 3, 4번 롤백 버튼을 클릭하여 현재 위치를 저장하거나, 저장된 위치로 이동할 수 있습니다.<br>
                - <strong>저장 해제:</strong> 저장된 위치로 이동하면 해당 롤백 위치는 자동으로 해제됩니다.<br><br>
                <strong>게임 관리:</strong><br>
                - <strong>크기 다시 설정:</strong> 새로운 미로 크기를 설정하고 게임을 다시 시작합니다.<br>
                - <strong>다시 시작:</strong> 현재 미로 크기로 새로운 미로를 생성하고 게임을 재시작합니다.<br><br>
                <strong>사운드:</strong><br>
                - <strong>이동:</strong> 말이 달리는 듯한 경쾌한 사운드가 재생됩니다.<br>
                - <strong>Q/E/롤백/공유:</strong> 재미있는 효과음이 재생됩니다.
            </p>
            <button id="closeHelpModalButton" class="action-button">닫기</button>
        </div>
    </div>

    <!-- Screenshot Display Modal -->
    <div id="screenshotModal" class="screenshot-modal">
        <div class="screenshot-modal-content">
            <h2>스크린샷</h2>
            <img id="screenshotImage" src="" alt="게임 스크린샷">
            <button id="closeScreenshotModalButton" class="action-button">닫기</button>
        </div>
    </div>

    <!-- Flash Overlay for screenshot effect -->
    <div id="flashOverlay" class="flash-overlay"></div>

    <script>
        // DOM 요소 가져오기
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const timerDisplay = document.getElementById('timer');
        const messageBox = document.getElementById('messageBox');
        const restartButton = document.getElementById('restartButton');
        const resetSizeButton = document.getElementById('resetSizeButton');
        const helpButton = document.getElementById('helpButton'); // Help button
        const qButton = document.getElementById('qButton'); // Q button
        const eButton = document.getElementById('eButton'); // E button
        const shareButton = document.getElementById('shareButton'); // Share button

        // 시작 화면 요소
        const startScreenModal = document.getElementById('startScreenModal');
        const mainLayout = document.querySelector('.main-layout');
        const ageButtonsContainer = document.getElementById('ageButtonsContainer');
        const customSizeBtn = document.getElementById('customSizeBtn');
        const customSizeContainer = document.getElementById('customSizeContainer');
        const mazeWidthSelect = document.getElementById('mazeWidthSelect');
        const mazeHeightSelect = document.getElementById('mazeHeightSelect');
        const startButton = document.getElementById('startButton');

        // --- New function to populate dropdowns ---
        function populateSizeDropdowns() {
            mazeWidthSelect.innerHTML = '';
            mazeHeightSelect.innerHTML = '';
            const sizes = [33, 45, 57, 69, 81, 93, 105, 117];
            sizes.forEach(size => {
                const optionWidth = document.createElement('option');
                optionWidth.value = size;
                optionWidth.textContent = `${size}`;
                mazeWidthSelect.appendChild(optionWidth);

                const optionHeight = document.createElement('option');
                optionHeight.value = size;
                optionHeight.textContent = `${size}`;
                mazeHeightSelect.appendChild(optionHeight);
            });
        }

        // --- New function to start the game with specific dimensions ---
        function startGameWithSize(width, height) {
            MAZE_WIDTH = width;
            MAZE_HEIGHT = height;

            startScreenModal.style.display = 'none';
            mainLayout.style.display = 'flex';
            initGame();
        }

        // Event listener for age buttons
        ageButtonsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('age-button')) {
                const size = parseInt(e.target.dataset.size);
                startGameWithSize(size, size);
            }
        });

        // Event listener for "직접 설정" button
        customSizeBtn.addEventListener('click', () => {
            ageButtonsContainer.parentElement.classList.add('hidden'); // Hide age buttons group
            customSizeContainer.classList.remove('hidden'); // Show custom size selectors
        });

        // Event listener for the main start button (now for custom sizes)
        startButton.addEventListener('click', () => {
            const width = parseInt(mazeWidthSelect.value);
            const height = parseInt(mazeHeightSelect.value);
            startGameWithSize(width, height);
        });

        // 롤백 버튼 (좌측)
        const rollback1_left = document.getElementById('rollback1_left');
        const rollback2_left = document.getElementById('rollback2_left');
        const rollback3_left = document.getElementById('rollback3_left');
        const rollback4_left = document.getElementById('rollback4_left');

        // 롤백 버튼 (우측)
        const rollback1_right = document.getElementById('rollback1_right');
        const rollback2_right = document.getElementById('rollback2_right');
        const rollback3_right = document.getElementById('rollback3_right');
        const rollback4_right = document.getElementById('rollback4_right');

        // 승리 화면 요소
        const winModal = document.getElementById('winModal');
        const winTimeMessage = document.getElementById('winTimeMessage'); // New element for time message
        const winMazeSizeMessage = document.getElementById('winMazeSizeMessage'); // NEW: Maze size message element
        const winRestartButton = document.getElementById('winRestartButton');
        const winEmoji = document.getElementById('winEmoji'); // Animated emoji element

        // 도움말 모달 요소
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalButton = document.getElementById('closeHelpModalButton');

        // 스크린샷 모달 요소
        const screenshotModal = document.getElementById('screenshotModal');
        const screenshotImage = document.getElementById('screenshotImage');
        const closeScreenshotModalButton = document.getElementById('closeScreenshotModalButton');
        const flashOverlay = document.getElementById('flashOverlay'); // Flash effect overlay

        // 게임 상태 변수
        let TILE_SIZE = 40; // Tile size (dynamically calculated)
        let MAZE_WIDTH = 11; // Maze width (set by user input)
        let MAZE_HEIGHT = 11; // Maze height (set by user input)

        let maze = []; // Maze array (dynamically generated)
        let player = { x: 0, y: 0 }; // Player current position (maze grid coordinates)
        let startPos = { x: 0, y: 0 }; // Start position
        let endPos = { x: 0, y: 0 }; // End position

        let startTime; // Timer start time
        let timerInterval; // Timer interval ID
        let gameWon = false; // Game won flag
        let eButtonUsed = false; // E button usage flag
        let qButtonUsed = false; // Q button usage flag (NEW)
        let playerPath = []; // Player movement path storage (max 80 cells)
        const MAX_PLAYER_PATH = 200; // Changed from 80 to 200
        let eButtonClearInterval = null; // Interval for clearing E button path
        let eButtonPathColor = ''; // Random color for E button path

        // Animation variables
        let animationFrameId;
        let flagYOffset = 0;
        let flagAnimationTime = 0;
        const flagFrames = ['🚩']; // Red and Blue flags
        const playerSprite = '🐎'; // Player character sprite

        // Rollback feature saved positions
        let savedPositions = {
            '1': null,
            '2': null,
            '3': null,
            '4': null
        };

        // Variables for continuous mouse movement
        var moveIntervals = {}; // Stores interval IDs for each directional button

        // Tone.js sound settings
        let runningSynth;
        let rollbackSynth;
        let impactSynth;
        let qButtonSynth; // Synth for Q button
        let eButtonSynth; // Synth for E button
        let shutterSynth; // Synth for camera shutter sound
        let audioContextResumed = false;

        // Array of notes for cheerful running sound
        const runningNotes = ["C4", "E4", "G4", "C5"];
        let currentRunningNoteIndex = 0;

        // Function to generate a random transparent RGBA color
        function getRandomTransparentColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            const a = 0.5; // Fixed transparency
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function initAudio() {
            // Running sound: more cheerful and diverse
            runningSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: {
                    type: "triangle" // Brighter sound
                },
                envelope: {
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();

            // Rollback sound: short, higher-pitched chime
            rollbackSynth = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.0,
                    release: 0.2
                }
            }).toDestination();

            // Impact sound for game start
            impactSynth = new Tone.MembraneSynth({
                pitchDecay: 0.08,
                octaves: 1,
                envelope: {
                    attack: 0.001,
                    decay: 0.4,
                    sustain: 0.01,
                    release: 0.6
                },
                oscillator: { type: "sine" }
            }).toDestination();

            // Q button sound: a quick, distinct tone
            qButtonSynth = new Tone.Synth({
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();

            // E button sound: a different quick tone
            eButtonSynth = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: {
                    attack: 0.005,
                    decay: 0.15,
                    sustain: 0.0,
                    release: 0.15
                }
            }).toDestination();

            // Shutter sound for screenshot
            shutterSynth = new Tone.NoiseSynth({
                noise: {
                    type: "white"
                },
                envelope: {
                    attack: 0.001,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();


            // Resume audio context on first user interaction
            document.documentElement.addEventListener('mousedown', () => {
                if (!audioContextResumed) {
                    Tone.start();
                    audioContextResumed = true;
                    console.log("AudioContext resumed!");
                }
            }, { once: true });
        }

        function playRunningSound() {
            if (audioContextResumed) {
                const note = runningNotes[currentRunningNoteIndex];
                runningSynth.triggerAttackRelease(note, "16n"); // Play the current note
                currentRunningNoteIndex = (currentRunningNoteIndex + 1) % runningNotes.length; // Move to the next note
            }
        }

        function playRollbackSound() {
            if (audioContextResumed) {
                rollbackSynth.triggerAttackRelease("G5", "16n"); // Higher note, very short duration
            }
        }

        function playImpactSound() {
            if (audioContextResumed) {
                impactSynth.triggerAttackRelease("C1", "8n"); // Low thump
                setTimeout(() => {
                    impactSynth.triggerAttackRelease("G1", "8n"); // Slightly higher thump
                }, 200);
            }
        }

        function playQButtonSound() {
            if (audioContextResumed) {
                qButtonSynth.triggerAttackRelease("A4", "8n"); // A quick high tone
            }
        }

        function playEButtonSound() {
            if (audioContextResumed) {
                eButtonSynth.triggerAttackRelease("F4", "8n"); // A quick mid tone
            }
        }

        function playShutterSound() {
            if (audioContextResumed) {
                shutterSynth.triggerAttackRelease("8n"); // A short noise burst
            }
        }


        // Function to initialize canvas size based on maze dimensions and available space
        function initializeCanvasSize() {
            const minTileSize = 5; // Minimum readable tile size
            const maxTileSize = 15; // Maximum comfortable tile size

            const headerElement = document.querySelector('.game-header');
            if (!headerElement) {
                console.error("Game header not found!");
                return;
            }

            const headerStyle = window.getComputedStyle(headerElement);
            const headerPaddingLeft = parseFloat(headerStyle.paddingLeft);
            const headerPaddingRight = parseFloat(headerStyle.paddingRight);
            const headerPaddingTop = parseFloat(headerStyle.paddingTop);
            const headerPaddingBottom = parseFloat(headerStyle.paddingBottom);

            const availableWidthForCanvas = headerElement.clientWidth - headerPaddingLeft - headerPaddingRight;
            const availableHeightForCanvas = headerElement.clientHeight - headerPaddingTop - headerPaddingBottom;

            let calculatedTileSizeHeight = Math.floor(availableHeightForCanvas / MAZE_HEIGHT);
            let calculatedTileSizeWidth = Math.floor(availableWidthForCanvas / MAZE_WIDTH);

            TILE_SIZE = Math.min(calculatedTileSizeHeight, calculatedTileSizeWidth);
            TILE_SIZE = Math.max(minTileSize, Math.min(TILE_SIZE, maxTileSize));

            canvas.width = MAZE_WIDTH * TILE_SIZE;
            canvas.height = MAZE_HEIGHT * TILE_SIZE;
        }

        // Function to generate the maze (Recursive Backtracker algorithm)
        function generateMaze() {
            const pathSize = 3;
            const wallSize = 1;
            const step = pathSize + wallSize; // 4

            // Initialize all cells as walls (1 is wall)
            maze = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(1));

            const metaWidth = Math.floor((MAZE_WIDTH - wallSize) / step);
            const metaHeight = Math.floor((MAZE_HEIGHT - wallSize) / step);

            if (metaWidth <= 0 || metaHeight <= 0) {
                console.error("Maze size is too small for this structure.");
                maze = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(0));
                placeStartEnd();
                return;
            }

            let metaVisited = Array(metaHeight).fill(0).map(() => Array(metaWidth).fill(false));
            let stack = [];

            let startMetaX = Math.floor(Math.random() * metaWidth);
            let startMetaY = Math.floor(Math.random() * metaHeight);

            stack.push({ x: startMetaX, y: startMetaY });
            metaVisited[startMetaY][startMetaX] = true;
            
            // Carve the first 3x3 cell
            let startX = wallSize + startMetaX * step;
            let startY = wallSize + startMetaY * step;
            for (let r = 0; r < pathSize; r++) {
                for (let c = 0; c < pathSize; c++) {
                    if (startY + r < MAZE_HEIGHT && startX + c < MAZE_WIDTH) {
                        maze[startY + r][startX + c] = 0;
                    }
                }
            }

            while (stack.length > 0) {
                let current = stack[stack.length - 1];

                let neighbors = [];
                if (current.y > 0 && !metaVisited[current.y - 1][current.x]) neighbors.push({ x: current.x, y: current.y - 1, dir: 'N' });
                if (current.y < metaHeight - 1 && !metaVisited[current.y + 1][current.x]) neighbors.push({ x: current.x, y: current.y + 1, dir: 'S' });
                if (current.x > 0 && !metaVisited[current.y][current.x - 1]) neighbors.push({ x: current.x - 1, y: current.y, dir: 'W' });
                if (current.x < metaWidth - 1 && !metaVisited[current.y][current.x + 1]) neighbors.push({ x: current.x + 1, y: current.y, dir: 'E' });

                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];

                    let currentX = wallSize + current.x * step;
                    let currentY = wallSize + current.y * step;

                    // Carve the wall between current and next
                    if (next.dir === 'N') {
                        for(let i = 0; i < pathSize; i++) maze[currentY - 1][currentX + i] = 0;
                    } else if (next.dir === 'S') {
                        for(let i = 0; i < pathSize; i++) maze[currentY + pathSize][currentX + i] = 0;
                    } else if (next.dir === 'W') {
                        for(let i = 0; i < pathSize; i++) maze[currentY + i][currentX - 1] = 0;
                    } else if (next.dir === 'E') {
                        for(let i = 0; i < pathSize; i++) maze[currentY + i][currentX + pathSize] = 0;
                    }
                    
                    // Carve the 3x3 block for the next cell
                    let nextX = wallSize + next.x * step;
                    let nextY = wallSize + next.y * step;
                     for (let r = 0; r < pathSize; r++) {
                        for (let c = 0; c < pathSize; c++) {
                             if (nextY + r < MAZE_HEIGHT && nextX + c < MAZE_WIDTH) {
                                maze[nextY + r][nextX + c] = 0;
                            }
                        }
                    }

                    metaVisited[next.y][next.x] = true;
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }
            placeStartEnd();
        }

        // Function to randomly place start and end points on paths
        function placeStartEnd() {
            let pathCells = [];
            const pathSize = 3;
            const wallSize = 1;
            const step = pathSize + wallSize; // 4
            const pathCenterOffset = Math.floor(pathSize / 2);

            const metaWidth = Math.floor((MAZE_WIDTH - wallSize) / step);
            const metaHeight = Math.floor((MAZE_HEIGHT - wallSize) / step);

            for (let my = 0; my < metaHeight; my++) {
                for (let mx = 0; mx < metaWidth; mx++) {
                    const centerX = wallSize + mx * step + pathCenterOffset;
                    const centerY = wallSize + my * step + pathCenterOffset;

                    if (maze[centerY]?.[centerX] === 0) {
                        pathCells.push({ x: centerX, y: centerY });
                    }
                }
            }

            if (pathCells.length < 2) {
                console.error("Cannot place start/end, not enough center path cells found. Falling back to any path cell.");
                 // Fallback to any path cell if center cells are not found
                 for (let r = 0; r < MAZE_HEIGHT; r++) {
                    for (let c = 0; c < MAZE_WIDTH; c++) {
                        if (maze[r][c] === 0) {
                            pathCells.push({ x: c, y: r });
                        }
                    }
                }
                 if (pathCells.length < 2) { // If still not enough, hardcode
                    startPos = { x: 1 + pathCenterOffset, y: 1 + pathCenterOffset };
                    endPos = { x: MAZE_WIDTH - 2 - pathCenterOffset, y: MAZE_HEIGHT - 2 - pathCenterOffset };
                    player = { ...startPos };
                    return;
                }
            }

            let startIndex = Math.floor(Math.random() * pathCells.length);
            startPos = pathCells[startIndex];
            player = { ...startPos };
            playerPath = [{ ...player }];

            let endIndex;
            do {
                endIndex = Math.floor(Math.random() * pathCells.length);
            } while (endIndex === startIndex);
            endPos = pathCells[endIndex];
        }

        // Function to draw the maze, player, start, and end points
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            for (let r = 0; r < maze.length; r++) {
                for (let c = 0; c < maze[r].length; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;

                    if (maze[r][c] === 0) {
                        ctx.fillStyle = '#FFFFFF';
                    } else {
                        ctx.fillStyle = '#555555';
                    }
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }

            if (eButtonUsed && playerPath.length > 0) {
                ctx.fillStyle = eButtonPathColor;
                for (let i = 0; i < playerPath.length; i++) {
                    const pathX = playerPath[i].x * TILE_SIZE;
                    const pathY = playerPath[i].y * TILE_SIZE;
                    ctx.fillRect(pathX, pathY, TILE_SIZE, TILE_SIZE);
                }
            }

            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(startPos.x * TILE_SIZE + TILE_SIZE / 2, startPos.y * TILE_SIZE + TILE_SIZE / 2, (TILE_SIZE / 4) * 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = `${TILE_SIZE * 0.4 * 3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('●', startPos.x * TILE_SIZE + TILE_SIZE / 2, startPos.y * TILE_SIZE + TILE_SIZE / 2);

            ctx.font = `${TILE_SIZE * 0.7 * 3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(flagFrames[0], endPos.x * TILE_SIZE + TILE_SIZE / 2, endPos.y * TILE_SIZE + TILE_SIZE / 2 + flagYOffset);

            ctx.font = `${TILE_SIZE * 0.8 * 3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(playerSprite, player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2);

            for (const key in savedPositions) {
                const pos = savedPositions[key];
                if (pos) {
                    ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
                    ctx.beginPath();
                    ctx.arc(pos.x * TILE_SIZE + TILE_SIZE / 2, pos.y * TILE_SIZE + TILE_SIZE / 2, (TILE_SIZE / 2.5) * 3, 0, Math.PI * 2);
                    ctx.fill();

                    switch (key) {
                        case '1': ctx.fillStyle = 'red'; break;
                        case '2': ctx.fillStyle = 'orange'; break;
                        case '3': ctx.fillStyle = 'yellow'; break;
                        case '4': ctx.fillStyle = 'green'; break;
                        default: ctx.fillStyle = 'white';
                    }

                    ctx.font = `${TILE_SIZE * 0.6 * 3}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(key, pos.x * TILE_SIZE + TILE_SIZE / 2, pos.y * TILE_SIZE + TILE_SIZE / 2);
                }
            }
        }

        // --- Animation Loop ---
        function animate() {
            if (gameWon) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const animationSpeed = 0.05;
            flagAnimationTime += animationSpeed;
            flagYOffset = Math.sin(flagAnimationTime) * (TILE_SIZE * 0.15);

            drawMaze();
            animationFrameId = requestAnimationFrame(animate);
        }

        // Function to move the player
        function movePlayer(dx, dy) {
            if (gameWon) return;
            
            const pathSize = 3;
            const wallSize = 1;
            const step = pathSize + wallSize; // 4
            const pathCenterOffset = Math.floor(pathSize / 2); // 1

            // Calculate the wall cell to check
            const wallCheckX = player.x + dx * (pathCenterOffset + wallSize);
            const wallCheckY = player.y + dy * (pathCenterOffset + wallSize);

            // Check boundaries for the wall cell
            if (wallCheckX < 0 || wallCheckX >= MAZE_WIDTH || wallCheckY < 0 || wallCheckY >= MAZE_HEIGHT) {
                return;
            }

            // Check if the wall cell is a path (i.e., has been carved)
            if (maze[wallCheckY]?.[wallCheckX] === 0) {
                const newX = player.x + dx * step;
                const newY = player.y + dy * step;
                
                player.x = newX;
                player.y = newY;

                if (!eButtonUsed) {
                    playerPath.push({ x: player.x, y: player.y });
                    if (playerPath.length > MAX_PLAYER_PATH) {
                        playerPath.shift();
                    }
                }

                drawMaze();
                checkWin();
                playRunningSound();
            }
        }

        // Function to update timer display
        function updateTimerDisplay() {
            const elapsedTimeMs = Date.now() - startTime;
            const minutes = String(Math.floor(elapsedTimeMs / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((elapsedTimeMs % 60000) / 1000)).padStart(2, '0');
            const milliseconds = String(Math.floor((elapsedTimeMs % 1000) / 10)).padStart(2, '0');
            timerDisplay.textContent = `${minutes}분${seconds}초${milliseconds}`;
        }

        // Function to start the timer
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 10);
        }

        // Function to stop the timer
        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Function to display messages to the user
        function showMessage(message, type = 'info') {
            if (messageBox) {
                messageBox.textContent = message;
                messageBox.style.display = 'block';
                if (type === 'win') {
                    messageBox.className = 'message-box bg-green-200 text-green-800';
                } else if (type === 'error') {
                    messageBox.className = 'message-box bg-red-200 text-red-800';
                } else {
                    messageBox.className = 'message-box bg-yellow-200 text-yellow-800';
                }
            } else {
                console.error("messageBox element not found!");
            }
        }

        // Function to hide the message box
        function hideMessage() {
            if (messageBox) {
                messageBox.style.display = 'none';
            } else {
                console.error("messageBox element to hide not found!");
            }
        }

        // Function to check if the player has reached the end
        function checkWin() {
            if (player.x === endPos.x && player.y === endPos.y) {
                stopTimer();
                gameWon = true;
                winTimeMessage.textContent = `시간: ${timerDisplay.textContent}`;
                winMazeSizeMessage.textContent = `클리어한 미로 크기: ${MAZE_WIDTH} x ${MAZE_HEIGHT}`;
                winModal.style.display = 'flex';
            }
        }

        // Function to save or load position
        function saveOrLoadPosition(key) {
            if (gameWon) return;

            const currentPos = { x: player.x, y: player.y };
            const savedPos = savedPositions[key];

            if (savedPos && currentPos.x === savedPos.x && currentPos.y === savedPos.y) {
                savedPositions[key] = null;
                showMessage(`${key}번 위치 저장 해제됨.`);
            }
            else if (savedPos) {
                player.x = savedPos.x;
                player.y = savedPos.y;
                savedPositions[key] = null;
                showMessage(`${key}번 위치로 이동했습니다. 저장된 위치가 해제되었습니다.`);
                checkWin();
            }
            else {
                savedPositions[key] = { ...currentPos };
                showMessage(`${key}번 위치에 현재 위치를 저장했습니다.`);
            }
            drawMaze();
            playRollbackSound();
        }

        // Function to take screenshot and display it
        async function takeScreenshot() {
            playShutterSound();
            flashOverlay.classList.add('flash-effect');
            setTimeout(() => {
                flashOverlay.classList.remove('flash-effect');
            }, 300);

            try {
                const canvasElement = await html2canvas(mainLayout);
                const imageDataUrl = canvasElement.toDataURL('image/png');

                if (navigator.clipboard && navigator.clipboard.write) {
                    try {
                        const response = await fetch(imageDataUrl);
                        const blob = await response.blob();
                        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                        showMessage('스크린샷이 클립보드에 복사되었습니다!', 'info');
                    } catch (clipboardError) {
                        console.error('클립보드 복사 중 오류 발생 (navigator.clipboard.write):', clipboardError);
                        const tempInput = document.createElement('textarea');
                        tempInput.value = imageDataUrl;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        try {
                            document.execCommand('copy');
                            showMessage('스크린샷 데이터 URL이 클립보드에 복사되었습니다. (이미지 직접 복사 불가)', 'info');
                        } catch (execCommandError) {
                            console.error('execCommand("copy") 실패:', execCommandError);
                            showMessage('클립보드 복사 기능을 지원하지 않습니다.', 'error');
                        } finally {
                            document.body.removeChild(tempInput);
                        }
                    }
                } else {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = imageDataUrl;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        document.execCommand('copy');
                        showMessage('스크린샷 데이터 URL이 클립보드에 복사되었습니다. (이미지 직접 복사 불가)', 'info');
                    } catch (execCommandError) {
                        console.error('execCommand("copy") 실패:', execCommandError);
                        showMessage('클립보드 복사 기능을 지원하지 않습니다.', 'error');
                    } finally {
                        document.body.removeChild(tempInput);
                    }
                }

                screenshotImage.src = imageDataUrl;
                screenshotModal.style.display = 'flex';

            } catch (err) {
                console.error('스크린샷을 생성하거나 복사하는 중 오류 발생:', err);
                showMessage('스크린샷 처리 중 오류가 발생했습니다.', 'error');
            }
        }


        // Function to initialize the game
        function initGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            hideMessage();
            winModal.style.display = 'none';
            helpModal.style.display = 'none';
            screenshotModal.style.display = 'none';
            gameWon = false;
            
            eButtonUsed = false;
            eButton.disabled = false;
            eButton.classList.remove('disabled');
            if (eButtonClearInterval) {
                clearInterval(eButtonClearInterval);
                eButtonClearInterval = null;
            }
            eButtonPathColor = getRandomTransparentColor();

            qButtonUsed = false;
            qButton.disabled = false;
            qButton.classList.remove('disabled');
            
            stopTimer();
            timerDisplay.textContent = '00분00초00';
            for (let key in savedPositions) {
                savedPositions[key] = null;
            }

            initializeCanvasSize();
            generateMaze();
            playImpactSound();
            
            animate();
            startTimer();
        }

        // Function to show the start screen
        function showStartScreen() {
            startScreenModal.style.display = 'flex';
            mainLayout.style.display = 'none';
            winModal.style.display = 'none';
            helpModal.style.display = 'none';
            screenshotModal.style.display = 'none';

            ageButtonsContainer.parentElement.classList.remove('hidden');
            customSizeContainer.classList.add('hidden');
        }

        function startContinuousMove(direction) {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex') return;
            if (moveIntervals[direction]) return;

            const moveMap = {
                'up': () => movePlayer(0, -1),
                'down': () => movePlayer(0, 1),
                'left': () => movePlayer(-1, 0),
                'right': () => movePlayer(1, 0)
            };

            moveMap[direction]();
            moveIntervals[direction] = setInterval(moveMap[direction], 150);
        }

        function stopContinuousMove(direction) {
            if (moveIntervals[direction]) {
                clearInterval(moveIntervals[direction]);
                delete moveIntervals[direction];
            }
        }

        document.addEventListener('keydown', (e) => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex') return;

            if (['1', '2', '3', '4'].includes(e.key)) {
                saveOrLoadPosition(e.key);
                return;
            }

            if ((e.key === 'q' || e.key === 'Q') && !qButtonUsed) {
                qButtonUsed = true;
                qButton.disabled = true;
                qButton.classList.add('disabled');
                playQButtonSound();
                player.x = startPos.x;
                player.y = startPos.y;
                playerPath = [{ ...player }];
                drawMaze();
                showMessage("Q 버튼은 게임당 1회만 사용 가능합니다. 시작 지점으로 돌아왔습니다.");
                return;
            }

            if ((e.key === 'e' || e.key === 'E') && !eButtonUsed) {
                eButtonUsed = true;
                eButton.disabled = true;
                eButton.classList.add('disabled');
                playEButtonSound();
                showMessage(`최근 이동 경로 ${MAX_PLAYER_PATH}칸을 표시합니다. 0.5초마다 사라집니다.`);
                drawMaze();

                eButtonClearInterval = setInterval(() => {
                    if (playerPath.length > 0) {
                        playerPath.shift();
                        drawMaze();
                    } else {
                        clearInterval(eButtonClearInterval);
                        eButtonClearInterval = null;
                        showMessage("이동 경로 표시가 완료되었습니다.", 'info');
                    }
                }, 500);

                return;
            }

            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W': movePlayer(0, -1); break;
                case 'ArrowDown': case 's': case 'S': movePlayer(0, 1); break;
                case 'ArrowLeft': case 'a': case 'A': movePlayer(-1, 0); break;
                case 'ArrowRight': case 'd': case 'D': movePlayer(1, 0); break;
            }
        });

        document.getElementById('up').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('up'); });
        document.getElementById('down').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('down'); });
        document.getElementById('left').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('left'); });
        document.getElementById('right').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('right'); });

        qButton.addEventListener('click', () => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex' || qButtonUsed) return;
            qButtonUsed = true;
            qButton.disabled = true;
            qButton.classList.add('disabled');
            playQButtonSound();
            player.x = startPos.x;
            player.y = startPos.y;
            playerPath = [{ ...player }];
            drawMaze();
            showMessage("Q 버튼은 게임당 1회만 사용 가능합니다. 시작 지점으로 돌아왔습니다.");
        });

        eButton.addEventListener('click', () => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex' || eButtonUsed) return;
            eButtonUsed = true;
            eButton.disabled = true;
            eButton.classList.add('disabled');
            playEButtonSound();
            showMessage(`최근 이동 경로 ${MAX_PLAYER_PATH}칸을 표시합니다. 0.5초마다 사라집니다.`);
            drawMaze();

            eButtonClearInterval = setInterval(() => {
                if (playerPath.length > 0) {
                    playerPath.shift();
                    drawMaze();
                } else {
                    clearInterval(eButtonClearInterval);
                    eButtonClearInterval = null;
                    showMessage("이동 경로 표시가 완료되었습니다.", 'info');
                }
            }, 500);
        });

        shareButton.addEventListener('click', takeScreenshot);
        closeScreenshotModalButton.addEventListener('click', () => {
            screenshotModal.style.display = 'none';
        });

        document.addEventListener('mouseup', () => {
            for (const dir in moveIntervals) {
                stopContinuousMove(dir);
            }
        });

        document.getElementById('up').addEventListener('mouseleave', () => stopContinuousMove('up'));
        document.getElementById('down').addEventListener('mouseleave', () => stopContinuousMove('down'));
        document.getElementById('left').addEventListener('mouseleave', () => stopContinuousMove('left'));
        document.getElementById('right').addEventListener('mouseleave', () => stopContinuousMove('right'));
        qButton.addEventListener('mouseleave', () => stopContinuousMove('q'));
        eButton.addEventListener('mouseleave', () => stopContinuousMove('e'));

        rollback1_left.addEventListener('click', () => saveOrLoadPosition('1'));
        rollback2_left.addEventListener('click', () => saveOrLoadPosition('2'));
        rollback3_left.addEventListener('click', () => saveOrLoadPosition('3'));
        rollback4_left.addEventListener('click', () => saveOrLoadPosition('4'));

        rollback1_right.addEventListener('click', () => saveOrLoadPosition('1'));
        rollback2_right.addEventListener('click', () => saveOrLoadPosition('2'));
        rollback3_right.addEventListener('click', () => saveOrLoadPosition('3'));
        rollback4_right.addEventListener('click', () => saveOrLoadPosition('4'));

        restartButton.addEventListener('click', initGame);
        winRestartButton.addEventListener('click', () => {
            winModal.style.display = 'none';
            initGame();
        });

        resetSizeButton.addEventListener('click', showStartScreen);
        helpButton.addEventListener('click', () => {
            helpModal.style.display = 'flex';
        });
        closeHelpModalButton.addEventListener('click', () => {
            helpModal.style.display = 'none';
        });

        window.addEventListener('resize', () => {
            if (mainLayout.style.display === 'flex') {
                initGame();
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            populateSizeDropdowns();
            showStartScreen();
            initAudio();
        });
    </script>
</body>
</html>
