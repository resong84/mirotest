<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>미로 찾기 게임</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- html2canvas CDN for screenshot functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0; /* Remove body padding, handled by main-layout padding */
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrolling of the entire window */
        }
        .main-layout {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 600px; /* Max width for the whole game area */
            height: calc(100vh - 40px); /* Adjust height to fit viewport, considering body padding */
            box-sizing: border-box;
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* Ensure no scrollbars on the main layout itself */
            padding: 0; /* Remove padding from main-layout, header/footer will have it */
        }
        .game-header {
            height: 70%; /* 70% of main-layout height */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px; /* Inner padding for canvas */
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        .game-footer {
            height: 30%; /* 30% of main-layout height */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px; /* Gap between elements in footer */
            padding: 12px; /* Inner padding for controls */
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent footer from shrinking */
            margin-top: auto; /* Push footer to bottom if space allows */
            overflow-y: auto; /* Allow footer to scroll if its content exceeds 30% */
        }
        canvas {
            border: 2px solid #333;
            background-color: #eee;
            display: block;
            border-radius: 8px;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        .controls-wrapper { /* Wrapper for all controls (directional + rollback) */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Space between canvas and controls row */
            margin-top: 0; /* Managed by footer gap */
            width: 100%; /* Take full width to center content */
        }
        .main-controls-row { /* Container for left rollback, directional, right rollback */
            display: flex;
            align-items: center; /* Vertically center items */
            justify-content: space-between; /* Push rollback groups to edges */
            width: 95%; /* Make it wider to utilize space */
            max-width: 550px; /* Limit max width */
            margin: 0 auto; /* Center the row itself */
            gap: 0; /* Remove gap between groups, space-between handles it */
        }
        .directional-controls {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the rows */
            gap: 5px; /* Space between rows */
            width: 170px; /* Fixed width for the directional block */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .directional-row {
            display: flex;
            justify-content: center;
            gap: 5px; /* Space between buttons in a row */
            width: 100%;
        }
        .directional-row.top-row {
            justify-content: space-between; /* Distribute Q, Up, E */
            align-items: center;
            width: 100%;
            padding: 0 5px; /* Add some padding to prevent Q/E from touching edges */
            box-sizing: border-box;
        }
        .directional-row.middle-row { /* New row for left, down, right */
            justify-content: center; /* Center the buttons */
        }

        /* New base class for common button styles */
        .game-button-base {
            background-color: #FFFFFF;
            color: #000000;
            border-radius: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            padding: 0; /* Remove default padding, set by specific classes */
        }
        .game-button-base:hover {
            background-color: #F0F0F0;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .game-button-base:active {
            background-color: #D0D0D0;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .game-button-base:disabled {
            background-color: #cccccc;
            color: #888888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Specific styles for arrow buttons */
        .arrow-button {
            width: 50px; /* Fixed width */
            height: 50px; /* Fixed height for square shape */
            font-size: 1.8rem; /* Emoji size */
        }

        /* Specific styles for Q and E buttons */
        .special-action-button {
            width: 40px; /* Smaller width */
            height: 40px; /* Smaller height for square shape */
            font-size: 1.5rem; /* Smaller font size */
        }

        .rollback-group {
            display: grid; /* Changed to grid for 2x2 layout */
            grid-template-columns: repeat(2, 1fr); /* 2 columns */
            grid-template-rows: repeat(2, 1fr);    /* 2 rows */
            gap: 5px; /* Space between rollback buttons */
            width: 90px; /* Adjusted width for 2x2 */
            height: 90px; /* Adjusted height for 2x2 */
            align-items: center; /* Center buttons within their group */
            justify-content: center;
        }
        .rollback-button {
            width: 40px; /* Smaller fixed width */
            height: 40px; /* Smaller fixed height */
            border-radius: 8px; /* Slightly more rounded */
            font-size: 0.9rem;
            font-weight: bold;
            color: white; /* Text color for numbers */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: none; /* Remove default button border */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* Added text shadow for visibility */
        }
        .rollback-button:hover {
            transform: scale(1.05); /* Slight scale on hover */
        }
        .rollback-button:active {
            transform: scale(0.95);
        }
        /* Specific colors for rollback buttons (Pastel tones) */
        .rollback-button.red { background-color: #FFB6C1; } /* Pastel Pink */
        .rollback-button.orange { background-color: #FFDAB9; } /* Peach */
        .rollback-button.yellow { background-color: #FFFACD; } /* Lemon Chiffon */
        .rollback-button.green { background-color: #BDECB6; } /* Light Green */

        /* Modified .game-info-container to hold buttons and timer */
        .game-info-container {
            width: 100%;
            display: flex;
            justify-content: center; /* Center items horizontally */
            align-items: center; /* Align items vertically */
            gap: 15px; /* Space between buttons and timer */
            margin-top: 0; /* Managed by footer gap */
        }
        .timer-display {
            font-size: 1.2rem; /* Adjusted timer font size */
            font-weight: bold;
            color: #333;
            background-color: #f0f0f0;
            padding: 8px 16px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .message-box {
            background-color: #FEEBCB;
            color: #9C4221;
            padding: 12px 20px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            display: none;
            width: 100%;
            box-sizing: border-box;
            margin: 0; /* Removed margin, now managed by footer's gap */
        }
        .action-button { /* General style for action buttons */
            background-color: #BDECB6; /* Pastel Green */
            color: white;
            padding: 8px 16px; /* Adjusted padding to match timer */
            border-radius: 12px;
            font-size: 1.1rem; /* Adjusted font size for better fit */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .action-button:hover {
            background-color: #A7D8A0; /* Darker Pastel Green */
            transform: translateY(-2px);
        }
        .action-button:active {
            background-color: #92C38A; /* Even Darker Pastel Green */
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .reset-size-button {
            background-color: #FFB6C1; /* Pastel Pink */
        }
        .reset-size-button:hover {
            background-color: #FF9AA4; /* Darker Pastel Pink */
        }
        .reset-size-button:active {
            background-color: #FF7F8C; /* Even Darker Pastel Pink */
        }

        .help-button {
            background-color: #A7C7E7; /* Pastel Blue */
            color: white;
            padding: 8px 12px; /* Smaller padding for '?' */
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .help-button:hover {
            background-color: #92B4D8;
            transform: translateY(-2px);
        }
        .help-button:active {
            background-color: #7D9CC9;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }


        /* Start Screen Modal Styling */
        .start-screen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .start-screen-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .start-screen-content h2 {
            font-size: 2rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        .maze-size-input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .maze-size-input-group label {
            font-size: 1.1rem;
            color: #555;
        }
        .maze-size-input {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        .maze-size-input input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #ccc;
            border-radius: 8px;
            font-size: 1rem;
            text-align: center;
            -moz-appearance: textfield; /* Firefox hides arrows */
        }
        .maze-size-input input::-webkit-outer-spin-button,
        .maze-size-input input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .size-limit-text {
            font-size: 0.9rem;
            color: #777;
            margin-top: 5px;
        }
        .start-button {
            background-color: #4F46E5;
            color: white;
            padding: 14px 28px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
            margin-top: 10px;
        }
        .start-button:hover {
            background-color: #4338CA;
            transform: translateY(-3px);
        }
        .start-button:active {
            background-color: #3730A3;
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .start-screen-error {
            color: #EF4444; /* Red-500 */
            font-size: 0.9rem;
            margin-top: -10px;
            display: none;
        }

        /* Win Screen Modal Styling */
        .win-modal, .help-modal, .screenshot-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* 50% background blur effect */
            backdrop-filter: blur(5px); /* Optional: add actual blur if supported */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Above start screen modal */
            display: none; /* Hidden by default */
        }
        .win-modal-content, .help-modal-content, .screenshot-modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center; /* Center align content */
            max-width: 90%;
            width: 450px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        .win-message-line { /* For splitting win message into lines */
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 0; /* Remove default paragraph margins */
            line-height: 1.2; /* Adjust line height for better spacing */
        }
        #winEmoji { /* Style for the animated emoji */
            font-size: 6rem; /* Larger emoji */
            animation: bounce 1s infinite alternate; /* Simple bounce animation */
        }
        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-15px); }
        }

        .help-message-title {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }
        .help-message-content {
            font-size: 1rem;
            color: #555;
            text-align: left;
            line-height: 1.5;
        }
        .fireworks-gif { /* This class is now deprecated for the emoji */
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }
        .win-modal-buttons { /* New container for win modal buttons */
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }
        #winRestartButton, #shareButton, #closeHelpModalButton, #closeScreenshotModalButton { /* Combined styles */
            margin-top: 0; /* Managed by parent gap */
            background-color: #A7C7E7; /* Use pastel blue */
            padding: 8px 16px; /* Ensure consistent padding */
            font-size: 1.1rem; /* Ensure consistent font size */
            border-radius: 12px; /* Ensure consistent border-radius */
            flex-grow: 1; /* Allow buttons to grow and share space */
        }
        #winRestartButton:hover, #shareButton:hover, #closeHelpModalButton:hover, #closeScreenshotModalButton:hover {
            background-color: #92B4D8;
        }
        #winRestartButton:active, #shareButton:active, #closeHelpModalButton:active, #closeScreenshotModalButton:active {
            background-color: #7D9CC9;
        }

        /* Screenshot modal specific styles */
        .screenshot-modal-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .screenshot-buttons { /* This class is now deprecated, replaced by win-modal-buttons */
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }

        /* Flash effect overlay */
        .flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            z-index: 3000; /* Above all other modals */
            pointer-events: none; /* Allow clicks to pass through */
        }
        .flash-effect {
            animation: flash 0.3s ease-out forwards;
        }
        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }


        /* Responsive adjustments */
        @media (max-width: 640px) {
            .main-layout {
                padding: 16px;
                height: 100vh; /* Full height on mobile */
            }
            .game-header {
                height: 60%; /* Adjust header height for smaller screens */
            }
            .game-footer {
                height: 40%; /* Adjust footer height for smaller screens */
            }
            .directional-controls {
                width: 120px;
                height: auto; /* Changed to auto for flex layout */
                gap: 3px;
            }
            .arrow-button {
                width: 45px; /* Smaller square buttons on mobile */
                height: 45px;
                font-size: 1.5rem; /* Smaller arrows on smaller screens */
            }
            .special-action-button {
                width: 35px; /* Even smaller Q/E on mobile */
                height: 35px;
                font-size: 1.2rem;
            }
            .action-button {
                padding: 8px 16px; /* Match timer padding */
                font-size: 1rem;
            }
            .timer-display {
                font-size: 1.1rem; /* Slightly smaller timer on mobile */
                padding: 6px 12px;
            }
            .start-screen-content {
                padding: 20px;
                gap: 15px;
            }
            .start-screen-content h2 {
                font-size: 1.7rem;
            }
            .maze-size-input input {
                width: 70px;
                font-size: 0.9rem;
            }
            .start-button {
                padding: 12px 24px;
                font-size: 1.1rem;
            }
            .rollback-button {
                width: 35px; /* Even smaller on mobile */
                height: 35px;
                font-size: 0.8rem;
            }
            .main-controls-row {
                gap: 10px; /* Reduce gap on smaller screens */
            }
            .rollback-group {
                width: 80px; /* Adjust width for smaller rollback buttons */
                height: 80px; /* Adjust height for smaller rollback buttons */
            }
            #winEmoji {
                font-size: 4rem; /* Smaller emoji on mobile */
            }
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Start Screen Modal -->
    <div id="startScreenModal" class="start-screen-modal">
        <div class="start-screen-content">
            <h2>미로 찾기 게임</h2>
            <div class="maze-size-input-group">
                <label for="mazeWidthInput">미로 크기 설정:</label>
                <div class="maze-size-input">
                    <input type="number" id="mazeWidthInput" value="11" min="11" max="55">
                    <span>x</span>
                    <input type="number" id="mazeHeightInput" value="11" min="11" max="70">
                </div>
                <p class="size-limit-text">가로 길이는 11~55, 세로 길이는 11~70의 홀수여야 합니다.<br>짝수 입력 시 +1 됩니다.</p>
                <p id="sizeError" class="start-screen-error">유효하지 않은 크기입니다. 홀수 11~55 (가로), 11~70 (세로) 범위로 입력해주세요.</p>
            </div>
            <button id="startButton" class="start-button">게임 시작</button>
        </div>
    </div>

    <div class="main-layout" style="display: none;"> <!-- Initially hidden -->
        <header class="game-header">
            <canvas id="mazeCanvas"></canvas>
        </header>

        <footer class="game-footer">
            <div class="game-info-container">
                <button id="resetSizeButton" class="action-button reset-size-button">크기 다시 설정</button>
                <div id="timer" class="timer-display">00분00초00</div>
                <button id="restartButton" class="action-button">다시 시작</button>
                <button id="helpButton" class="help-button">?</button>
            </div>

            <div class="message-box" id="messageBox"></div> <!-- Moved here -->

            <div class="controls-wrapper">
                <div class="main-controls-row">
                    <!-- Left Rollback Buttons Group (2x2) -->
                    <div class="rollback-group">
                        <button id="rollback1_left" class="rollback-button red">1</button>
                        <button id="rollback2_left" class="rollback-button orange">2</button>
                        <button id="rollback3_left" class="rollback-button yellow">3</button>
                        <button id="rollback4_left" class="rollback-button green">4</button>
                    </div>

                    <!-- Directional Buttons -->
                    <div class="directional-row top-row">
                            <button id="qButton" class="game-button-base special-action-button">Q</button>
                            <button id="up" class="game-button-base arrow-button">⬆️</button>
                            <button id="eButton" class="game-button-base special-action-button">E</button>
                        </div>
                        <div class="directional-row middle-row">
                            <button id="left" class="game-button-base arrow-button">⬅️</button>
                            <button id="down" class="game-button-base arrow-button">⬇️</button>
                            <button id="right" class="game-button-base arrow-button">➡️</button>
                        </div>
                    </div>

                    <!-- Right Rollback Buttons Group (2x2) -->
                    <div class="rollback-group">
                        <button id="rollback1_right" class="rollback-button red">1</button>
                        <button id="rollback2_right" class="rollback-button orange">2</button>
                        <button id="rollback3_right" class="rollback-button yellow">3</button>
                        <button id="rollback4_right" class="rollback-button green">4</button>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <!-- Win Screen Modal -->
    <div id="winModal" class="win-modal">
        <div class="win-modal-content">
            <p class="win-message-line">축하합니다!</p>
            <p id="winTimeMessage" class="win-message-line"></p>
            <p id="winMazeSizeMessage" class="win-message-line"></p> <!-- NEW: Maze size message -->
            <span id="winEmoji">🎉</span> <!-- Animated emoji instead of GIF -->
            <div class="win-modal-buttons"> <!-- New container for buttons -->
                <button id="winRestartButton" class="action-button">다시 시작</button>
                <button id="shareButton" class="action-button">공유</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="help-modal">
        <div class="help-modal-content">
            <p class="help-message-title">미로 찾기 게임 설명</p>
            <p class="help-message-content">
                <strong>게임 목표:</strong> 말(플레이어)을 시작 지점(▶️)에서 도착 지점(🚩)까지 이동시켜 미로를 탈출하세요.<br><br>
                <strong>조작법:</strong><br>
                - <strong>이동:</strong> 키보드의 화살표 키(⬆️⬇️⬅️➡️) 또는 WASD 키(W:위, A:왼쪽, S:아래, D:오른쪽)를 사용하거나 화면의 방향키 버튼을 클릭하세요. 버튼을 누르고 있으면 연속 이동합니다.<br>
                - <strong>Q 버튼:</strong> 시작 지점으로 즉시 이동합니다. 게임당 1회만 사용 가능합니다.<br>
                - <strong>E 버튼:</b> 지나온 최근 200칸의 블록을 랜덤 색상으로 표시합니다. 게임당 1회만 사용 가능하며, 0.5초마다 한 칸씩 사라집니다.<br>
                - <strong>시간:</strong> 하단의 타이머가 미로를 탈출하는 데 걸린 시간을 측정합니다.<br><br>
                <strong>롤백 기능:</b><br>
                - <strong>저장/이동:</strong> 1, 2, 3, 4번 롤백 버튼을 클릭하여 현재 위치를 저장하거나, 저장된 위치로 이동할 수 있습니다.<br>
                - <strong>저장 해제:</strong> 저장된 위치로 이동하면 해당 롤백 위치는 자동으로 해제됩니다.<br><br>
                <strong>게임 관리:</strong><br>
                - <strong>크기 다시 설정:</strong> 새로운 미로 크기를 설정하고 게임을 다시 시작합니다.<br>
                - <strong>다시 시작:</strong> 현재 미로 크기로 새로운 미로를 생성하고 게임을 재시작합니다.<br><br>
                <strong>사운드:</strong><br>
                - <strong>이동:</strong> 말이 달리는 듯한 경쾌한 사운드가 재생됩니다.<br>
                - <strong>Q/E/롤백/공유:</strong> 재미있는 효과음이 재생됩니다.
            </p>
            <button id="closeHelpModalButton" class="action-button">닫기</button>
        </div>
    </div>

    <!-- Screenshot Display Modal -->
    <div id="screenshotModal" class="screenshot-modal">
        <div class="screenshot-modal-content">
            <h2>스크린샷</h2>
            <img id="screenshotImage" src="" alt="게임 스크린샷">
            <button id="closeScreenshotModalButton" class="action-button">닫기</button>
        </div>
    </div>

    <!-- Flash Overlay for screenshot effect -->
    <div id="flashOverlay" class="flash-overlay"></div>

    <script>
        // DOM 요소 가져오기
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const timerDisplay = document.getElementById('timer');
        const messageBox = document.getElementById('messageBox');
        const restartButton = document.getElementById('restartButton');
        const resetSizeButton = document.getElementById('resetSizeButton');
        const helpButton = document.getElementById('helpButton'); // Help button
        const qButton = document.getElementById('qButton'); // Q button
        const eButton = document.getElementById('eButton'); // E button
        const shareButton = document.getElementById('shareButton'); // Share button

        // 시작 화면 요소
        const startScreenModal = document.getElementById('startScreenModal');
        const mazeWidthInput = document.getElementById('mazeWidthInput');
        const mazeHeightInput = document.getElementById('mazeHeightInput');
        const startButton = document.getElementById('startButton');
        const sizeError = document.getElementById('sizeError');
        const mainLayout = document.querySelector('.main-layout'); // Renamed from gameContainer

        // 롤백 버튼 (좌측)
        const rollback1_left = document.getElementById('rollback1_left');
        const rollback2_left = document.getElementById('rollback2_left');
        const rollback3_left = document.getElementById('rollback3_left');
        const rollback4_left = document.getElementById('rollback4_left');

        // 롤백 버튼 (우측)
        const rollback1_right = document.getElementById('rollback1_right');
        const rollback2_right = document.getElementById('rollback2_right');
        const rollback3_right = document.getElementById('rollback3_right');
        const rollback4_right = document.getElementById('rollback4_right');

        // 승리 화면 요소
        const winModal = document.getElementById('winModal');
        const winTimeMessage = document.getElementById('winTimeMessage'); // New element for time message
        const winMazeSizeMessage = document.getElementById('winMazeSizeMessage'); // NEW: Maze size message element
        const winRestartButton = document.getElementById('winRestartButton');
        const winEmoji = document.getElementById('winEmoji'); // Animated emoji element

        // 도움말 모달 요소
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalButton = document.getElementById('closeHelpModalButton');

        // 스크린샷 모달 요소
        const screenshotModal = document.getElementById('screenshotModal');
        const screenshotImage = document.getElementById('screenshotImage');
        const closeScreenshotModalButton = document.getElementById('closeScreenshotModalButton');
        const flashOverlay = document.getElementById('flashOverlay'); // Flash effect overlay

        // 게임 상태 변수
        let TILE_SIZE = 40; // Tile size (dynamically calculated)
        let MAZE_WIDTH = 11; // Maze width (set by user input)
        let MAZE_HEIGHT = 11; // Maze height (set by user input)

        let maze = []; // Maze array (dynamically generated)
        let player = { x: 0, y: 0 }; // Player current position (maze grid coordinates)
        let startPos = { x: 0, y: 0 }; // Start position
        let endPos = { x: 0, y: 0 }; // End position

        let startTime; // Timer start time
        let timerInterval; // Timer interval ID
        let gameWon = false; // Game won flag
        let eButtonUsed = false; // E button usage flag
        let qButtonUsed = false; // Q button usage flag (NEW)
        let playerPath = []; // Player movement path storage (max 80 cells)
        const MAX_PLAYER_PATH = 200; // Changed from 80 to 200
        let eButtonClearInterval = null; // Interval for clearing E button path
        let eButtonPathColor = ''; // Random color for E button path

        // Rollback feature saved positions
        let savedPositions = {
            '1': null,
            '2': null,
            '3': null,
            '4': null
        };

        // Variables for continuous mouse movement
        var moveIntervals = {}; // Stores interval IDs for each directional button

        // Tone.js sound settings
        let runningSynth;
        let rollbackSynth;
        let impactSynth;
        let qButtonSynth; // Synth for Q button
        let eButtonSynth; // Synth for E button
        let shutterSynth; // Synth for camera shutter sound
        let audioContextResumed = false;

        // Array of notes for cheerful running sound
        const runningNotes = ["C4", "E4", "G4", "C5"];
        let currentRunningNoteIndex = 0;

        // Function to generate a random transparent RGBA color
        function getRandomTransparentColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            const a = 0.5; // Fixed transparency
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function initAudio() {
            // Running sound: more cheerful and diverse
            runningSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: {
                    type: "triangle" // Brighter sound
                },
                envelope: {
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();

            // Rollback sound: short, higher-pitched chime
            rollbackSynth = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.0,
                    release: 0.2
                }
            }).toDestination();

            // Impact sound for game start
            impactSynth = new Tone.MembraneSynth({
                pitchDecay: 0.08,
                octaves: 1,
                envelope: {
                    attack: 0.001,
                    decay: 0.4,
                    sustain: 0.01,
                    release: 0.6
                },
                oscillator: { type: "sine" }
            }).toDestination();

            // Q button sound: a quick, distinct tone
            qButtonSynth = new Tone.Synth({
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();

            // E button sound: a different quick tone
            eButtonSynth = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: {
                    attack: 0.005,
                    decay: 0.15,
                    sustain: 0.0,
                    release: 0.15
                }
            }).toDestination();

            // Shutter sound for screenshot
            shutterSynth = new Tone.NoiseSynth({
                noise: {
                    type: "white"
                },
                envelope: {
                    attack: 0.001,
                    decay: 0.1,
                    sustain: 0.0,
                    release: 0.1
                }
            }).toDestination();


            // Resume audio context on first user interaction
            document.documentElement.addEventListener('mousedown', () => {
                if (!audioContextResumed) {
                    Tone.start();
                    audioContextResumed = true;
                    console.log("AudioContext resumed!");
                }
            }, { once: true });
        }

        function playRunningSound() {
            if (audioContextResumed) {
                const note = runningNotes[currentRunningNoteIndex];
                runningSynth.triggerAttackRelease(note, "16n"); // Play the current note
                currentRunningNoteIndex = (currentRunningNoteIndex + 1) % runningNotes.length; // Move to the next note
            }
        }

        function playRollbackSound() {
            if (audioContextResumed) {
                rollbackSynth.triggerAttackRelease("G5", "16n"); // Higher note, very short duration
            }
        }

        function playImpactSound() {
            if (audioContextResumed) {
                impactSynth.triggerAttackRelease("C1", "8n"); // Low thump
                setTimeout(() => {
                    impactSynth.triggerAttackRelease("G1", "8n"); // Slightly higher thump
                }, 200);
            }
        }

        function playQButtonSound() {
            if (audioContextResumed) {
                qButtonSynth.triggerAttackRelease("A4", "8n"); // A quick high tone
            }
        }

        function playEButtonSound() {
            if (audioContextResumed) {
                eButtonSynth.triggerAttackRelease("F4", "8n"); // A quick mid tone
            }
        }

        function playShutterSound() {
            if (audioContextResumed) {
                shutterSynth.triggerAttackRelease("8n"); // A short noise burst
            }
        }


        // Function to initialize canvas size based on maze dimensions and available space
        function initializeCanvasSize() {
            const minTileSize = 10; // Minimum readable tile size
            const maxTileSize = 30; // Maximum comfortable tile size

            const headerElement = document.querySelector('.game-header');
            if (!headerElement) {
                console.error("Game header not found!");
                return;
            }

            const headerStyle = window.getComputedStyle(headerElement);
            const headerPaddingLeft = parseFloat(headerStyle.paddingLeft);
            const headerPaddingRight = parseFloat(headerStyle.paddingRight);
            const headerPaddingTop = parseFloat(headerStyle.paddingTop);
            const headerPaddingBottom = parseFloat(headerStyle.paddingBottom);

            const availableWidthForCanvas = headerElement.clientWidth - headerPaddingLeft - headerPaddingRight;
            const availableHeightForCanvas = headerElement.clientHeight - headerPaddingTop - headerPaddingBottom;

            let calculatedTileSizeHeight = Math.floor(availableHeightForCanvas / MAZE_HEIGHT);
            let calculatedTileSizeWidth = Math.floor(availableWidthForCanvas / MAZE_WIDTH);

            TILE_SIZE = Math.min(calculatedTileSizeHeight, calculatedTileSizeWidth);
            TILE_SIZE = Math.max(minTileSize, Math.min(TILE_SIZE, maxTileSize));

            canvas.width = MAZE_WIDTH * TILE_SIZE;
            canvas.height = MAZE_HEIGHT * TILE_SIZE;
        }

        // Function to generate the maze (Recursive Backtracker algorithm)
        function generateMaze() {
            // Initialize all cells as walls (1 is wall)
            maze = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(1));

            let visited = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(false));
            let stack = [];

            // Start from a random odd cell (to ensure it's a path)
            let startX = Math.floor(Math.random() * ((MAZE_WIDTH - 1) / 2)) * 2 + 1;
            let startY = Math.floor(Math.random() * ((MAZE_HEIGHT - 1) / 2)) * 2 + 1;

            // Ensure startX, startY are within bounds for odd dimensions
            if (startX < 1) startX = 1;
            if (startY < 1) startY = 1;
            if (startX >= MAZE_WIDTH - 1) startX = MAZE_WIDTH - 2;
            if (startY >= MAZE_HEIGHT - 1) startY = MAZE_HEIGHT - 2;


            stack.push({ x: startX, y: startY });
            visited[startY][startX] = true;
            maze[startY][startX] = 0; // Mark as path

            while (stack.length > 0) {
                let current = stack[stack.length - 1]; // Peek at the top of the stack

                let neighbors = [];
                // Check unvisited neighbors (2 cells away, to break walls between cells)
                // Up
                if (current.y - 2 >= 0 && !visited[current.y - 2][current.x]) {
                    neighbors.push({ x: current.x, y: current.y - 2, wallX: current.x, wallY: current.y - 1 });
                }
                // Down
                if (current.y + 2 < MAZE_HEIGHT && !visited[current.y + 2][current.x]) {
                    neighbors.push({ x: current.x, y: current.y + 2, wallX: current.x, wallY: current.y + 1 });
                }
                // Left
                if (current.x - 2 >= 0 && !visited[current.y][current.x - 2]) {
                    neighbors.push({ x: current.x - 2, y: current.y, wallX: current.x - 1, wallY: current.y });
                }
                // Right
                if (current.x + 2 < MAZE_WIDTH && !visited[current.y][current.x + 2]) {
                    neighbors.push({ x: current.x + 2, y: current.y, wallX: current.x + 1, wallY: current.y });
                }

                if (neighbors.length > 0) {
                    // Choose a random neighbor
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];

                    // Remove the wall between the current cell and the next cell
                    maze[next.wallY][next.wallX] = 0;
                    maze[next.y][next.x] = 0; // Mark next cell as path
                    visited[next.y][next.x] = true;
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop(); // Backtrack
                }
            }

            // Ensure outer border is walls
            for (let i = 0; i < MAZE_HEIGHT; i++) {
                maze[i][0] = 1;
                maze[i][MAZE_WIDTH - 1] = 1;
            }
            for (let j = 0; j < MAZE_WIDTH; j++) {
                maze[0][j] = 1;
                maze[MAZE_HEIGHT - 1][j] = 1;
            }

            // Place start and end points
            placeStartEnd();
        }

        // Function to randomly place start and end points on paths
        function placeStartEnd() {
            let pathCells = [];
            for (let r = 0; r < MAZE_HEIGHT; r++) {
                for (let c = 0; c < MAZE_WIDTH; c++) {
                    if (maze[r][c] === 0) {
                        pathCells.push({ x: c, y: r });
                    }
                }
            }

            // Select start position randomly from path cells
            let startIndex = Math.floor(Math.random() * pathCells.length);
            startPos = pathCells[startIndex];
            player = { x: startPos.x, y: startPos.y };
            playerPath = [{ x: player.x, y: player.y }]; // Initialize player path

            // Select end position randomly (different from start and meeting distance criteria)
            let endIndex;
            let distanceConditionMet = false;
            // Calculate minDistance: (width * height) / ((width + height) / 2)
            const minDistance = (MAZE_WIDTH * MAZE_HEIGHT) / ((MAZE_WIDTH + MAZE_HEIGHT) / 2);
            let retryCount = 0;
            const MAX_RETRIES = 1000; // Prevent infinite loop

            while (!distanceConditionMet && retryCount < MAX_RETRIES) {
                endIndex = Math.floor(Math.random() * pathCells.length);
                if (endIndex === startIndex) { // Ensure start and end are different
                    retryCount++;
                    continue;
                }

                const tempEndPos = pathCells[endIndex];
                // Calculate Manhattan distance
                const currentDistance = Math.abs(startPos.x - tempEndPos.x) + Math.abs(startPos.y - tempEndPos.y);

                if (currentDistance > minDistance) {
                    endPos = tempEndPos;
                    distanceConditionMet = true;
                }
                retryCount++;
            }

            // Fallback if a sufficiently distant end point is not found after many retries
            if (!distanceConditionMet) {
                do {
                    endIndex = Math.floor(Math.random() * pathCells.length);
                } while (endIndex === startIndex);
                endPos = pathCells[endIndex];
                console.warn("Could not find a sufficiently distant end point, selecting another random point.");
            }
        }

        // Function to draw the maze, player, start, and end points
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            for (let r = 0; r < maze.length; r++) {
                for (let c = 0; c < maze[r].length; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;

                    // Draw path (white) or wall (dark gray)
                    if (maze[r][c] === 0) {
                        ctx.fillStyle = '#FFFFFF'; // White for path
                    } else if (maze[r][c] === 1) {
                        ctx.fillStyle = '#555555'; // Dark gray for walls
                    }
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw E button path if used
            if (eButtonUsed && playerPath.length > 0) {
                ctx.fillStyle = eButtonPathColor; // Use the random color
                for (let i = 0; i < playerPath.length; i++) {
                    const pathX = playerPath[i].x * TILE_SIZE;
                    const pathY = playerPath[i].y * TILE_SIZE;
                    ctx.fillRect(pathX, pathY, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw start point marker (small circle)
            ctx.fillStyle = '#4CAF50'; // Green dot for start
            ctx.beginPath();
            ctx.arc(startPos.x * TILE_SIZE + TILE_SIZE / 2, startPos.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = `${TILE_SIZE * 0.4}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('●', startPos.x * TILE_SIZE + TILE_SIZE / 2, startPos.y * TILE_SIZE + TILE_SIZE / 2);


            // Draw end point marker
            ctx.font = `${TILE_SIZE * 0.7}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🚩', endPos.x * TILE_SIZE + TILE_SIZE / 2, endPos.y * TILE_SIZE + TILE_SIZE / 2); // Red triangular flag emoji

            // Draw player (at current position)
            ctx.font = `${TILE_SIZE * 0.8}px Arial`; // Horse emoji size adjustment
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🐎', player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2); // Horse emoji


            // Draw saved positions
            for (const key in savedPositions) {
                const pos = savedPositions[key];
                if (pos) {
                    // Use a slightly transparent background for better visibility of numbers
                    ctx.fillStyle = 'rgba(128, 128, 128, 0.5)'; // Gray, semi-transparent
                    ctx.beginPath();
                    ctx.arc(pos.x * TILE_SIZE + TILE_SIZE / 2, pos.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Apply specific color to number text based on key
                    switch (key) {
                        case '1':
                            ctx.fillStyle = 'red';
                            break;
                        case '2':
                            ctx.fillStyle = 'orange';
                            break;
                        case '3':
                            ctx.fillStyle = 'yellow';
                            break;
                        case '4':
                            ctx.fillStyle = 'green';
                            break;
                        default:
                            ctx.fillStyle = 'white'; // Default
                    }

                    ctx.font = `${TILE_SIZE * 0.4}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(key, pos.x * TILE_SIZE + TILE_SIZE / 2, pos.y * TILE_SIZE + TILE_SIZE / 2);
                }
            }
        }

        // Function to move the player
        function movePlayer(dx, dy) {
            if (gameWon) return; // Prevent movement after winning

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check boundaries
            if (newX >= 0 && newX < MAZE_WIDTH && newY >= 0 && newY < MAZE_HEIGHT) {
                // Check if the new position is not a wall
                if (maze[newY][newX] !== 1) {
                    player.x = newX;
                    player.y = newY;
                    
                    // Add current position to player path ONLY if E button has NOT been used
                    if (!eButtonUsed) { // Only add to path if E button hasn't been used
                        playerPath.push({ x: player.x, y: player.y });
                        if (playerPath.length > MAX_PLAYER_PATH) { // Changed to MAX_PLAYER_PATH
                            playerPath.shift(); // Keep only the last MAX_PLAYER_PATH positions
                        }
                    }

                    drawMaze();
                    checkWin();
                    playRunningSound(); // Play sound on player movement
                }
            }
        }

        // Function to update timer display
        function updateTimerDisplay() {
            const elapsedTimeMs = Date.now() - startTime;
            const minutes = String(Math.floor(elapsedTimeMs / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((elapsedTimeMs % 60000) / 1000)).padStart(2, '0');
            const milliseconds = String(Math.floor((elapsedTimeMs % 1000) / 10)).padStart(2, '0'); // Two digits for milliseconds
            timerDisplay.textContent = `${minutes}분${seconds}초${milliseconds}`;
        }

        // Function to start the timer
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 10); // Update every 10ms
        }

        // Function to stop the timer
        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Function to display messages to the user
        function showMessage(message, type = 'info') {
            if (messageBox) {
                messageBox.textContent = message;
                messageBox.style.display = 'block';
                if (type === 'win') {
                    messageBox.className = 'message-box bg-green-200 text-green-800';
                } else if (type === 'error') {
                    messageBox.className = 'message-box bg-red-200 text-red-800';
                } else {
                    messageBox.className = 'message-box bg-yellow-200 text-yellow-800';
                }
            } else {
                console.error("messageBox element not found!");
            }
        }

        // Function to hide the message box
        function hideMessage() {
            if (messageBox) {
                messageBox.style.display = 'none';
            } else {
                console.error("messageBox element to hide not found!");
            }
        }

        // Function to check if the player has reached the end
        function checkWin() {
            if (player.x === endPos.x && player.y === endPos.y) {
                stopTimer();
                gameWon = true;
                // Update win message and display win modal
                winTimeMessage.textContent = `시간: ${timerDisplay.textContent}`; // Update time message
                winMazeSizeMessage.textContent = `클리어한 미로 크기: ${MAZE_WIDTH} x ${MAZE_HEIGHT}`; // NEW: Update maze size message
                winModal.style.display = 'flex';
            }
        }

        // Function to save or load position
        function saveOrLoadPosition(key) {
            if (gameWon) return;

            const currentPos = { x: player.x, y: player.y };
            const savedPos = savedPositions[key];

            // If current position is same as saved position (to clear it)
            if (savedPos && currentPos.x === savedPos.x && currentPos.y === savedPos.y) {
                savedPositions[key] = null; // Clear saved position
                showMessage(`${key}번 위치 저장 해제됨.`);
            }
            // If position is saved (and different from current), move to that position
            else if (savedPos) {
                player.x = savedPos.x;
                player.y = savedPos.y;
                savedPositions[key] = null; // Clear after loading
                showMessage(`${key}번 위치로 이동했습니다. 저장된 위치가 해제되었습니다.`);
                checkWin(); // Check win condition after movement
            }
            // If no position is saved, save current position
            else {
                savedPositions[key] = { x: currentPos.x, y: currentPos.y };
                showMessage(`${key}번 위치에 현재 위치를 저장했습니다.`);
            }
            drawMaze(); // Redraw to update saved position markers
            playRollbackSound(); // Play sound on rollback
        }

        // Function to take screenshot and display it
        async function takeScreenshot() {
            playShutterSound(); // Play shutter sound
            flashOverlay.classList.add('flash-effect'); // Add flash effect
            setTimeout(() => {
                flashOverlay.classList.remove('flash-effect'); // Remove flash effect after animation
            }, 300); // Match animation duration

            try {
                // Capture the main game layout
                const canvasElement = await html2canvas(mainLayout);
                const imageDataUrl = canvasElement.toDataURL('image/png');

                // Attempt to copy to clipboard using modern Clipboard API
                if (navigator.clipboard && navigator.clipboard.write) {
                    try {
                        const response = await fetch(imageDataUrl);
                        const blob = await response.blob();
                        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                        showMessage('스크린샷이 클립보드에 복사되었습니다!', 'info');
                    } catch (clipboardError) {
                        console.error('클립보드 복사 중 오류 발생 (navigator.clipboard.write):', clipboardError);
                        // Fallback to text copy if image blob copy fails due to permissions
                        const tempInput = document.createElement('textarea');
                        tempInput.value = imageDataUrl; // Copy the data URL as text
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        try {
                            document.execCommand('copy');
                            showMessage('스크린샷 데이터 URL이 클립보드에 복사되었습니다. (이미지 직접 복사 불가)', 'info');
                        } catch (execCommandError) {
                            console.error('execCommand("copy") 실패:', execCommandError);
                            showMessage('클립보드 복사 기능을 지원하지 않습니다.', 'error');
                        } finally {
                            document.body.removeChild(tempInput);
                        }
                    }
                } else {
                    // Fallback for browsers that don't support Clipboard API at all
                    const tempInput = document.createElement('textarea');
                    tempInput.value = imageDataUrl; // Copy the data URL as text
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        document.execCommand('copy');
                        showMessage('스크린샷 데이터 URL이 클립보드에 복사되었습니다. (이미지 직접 복사 불가)', 'info');
                    } catch (execCommandError) {
                        console.error('execCommand("copy") 실패:', execCommandError);
                        showMessage('클립보드 복사 기능을 지원하지 않습니다.', 'error');
                    } finally {
                        document.body.removeChild(tempInput);
                    }
                }

                // Always display screenshot in modal
                screenshotImage.src = imageDataUrl;
                screenshotModal.style.display = 'flex';

            } catch (err) {
                console.error('스크린샷을 생성하거나 복사하는 중 오류 발생:', err);
                showMessage('스크린샷 처리 중 오류가 발생했습니다.', 'error');
            }
        }


        // Function to initialize the game
        function initGame() {
            hideMessage();
            winModal.style.display = 'none'; // Hide win modal
            helpModal.style.display = 'none'; // Hide help modal
            screenshotModal.style.display = 'none'; // Hide screenshot modal
            gameWon = false;
            
            // Reset E button usage
            eButtonUsed = false;
            eButton.disabled = false;
            eButton.classList.remove('disabled');
            // Clear E button path interval if active
            if (eButtonClearInterval) {
                clearInterval(eButtonClearInterval);
                eButtonClearInterval = null;
            }
            eButtonPathColor = getRandomTransparentColor(); // Set a new random color for the E button path

            // Reset Q button usage (NEW)
            qButtonUsed = false;
            qButton.disabled = false;
            qButton.classList.remove('disabled');
            
            stopTimer(); // Clear existing timer
            timerDisplay.textContent = '00분00초00'; // Reset timer display
            // Clear all saved positions
            for (let key in savedPositions) {
                savedPositions[key] = null;
            }

            initializeCanvasSize(); // Calculate TILE_SIZE and set canvas size
            generateMaze(); // Generate new maze (includes placeStartEnd())
            playImpactSound(); // Play sound to emphasize player/end point location
            drawMaze(); // Draw maze (including player/end point)
            startTimer(); // Start timer
        }

        // Function to show the start screen
        function showStartScreen() {
            startScreenModal.style.display = 'flex';
            mainLayout.style.display = 'none'; // Hide mainLayout
            sizeError.style.display = 'none'; // Hide error message initially
            winModal.style.display = 'none'; // Hide win modal when returning to start screen
            helpModal.style.display = 'none'; // Hide help modal when returning to start screen
            screenshotModal.style.display = 'none'; // Hide screenshot modal when returning to start screen
        }

        // Event listener for start button click
        startButton.addEventListener('click', () => {
            let inputWidth = parseInt(mazeWidthInput.value);
            let inputHeight = parseInt(mazeHeightInput.value);

            // Validation: must be odd numbers within 11-55 (width), 11-70 (height)
            if (isNaN(inputWidth) || isNaN(inputHeight) || inputWidth < 11 || inputWidth > 55 || inputHeight < 11 || inputHeight > 70) {
                sizeError.style.display = 'block';
                return;
            }

            // If even, increment by 1
            if (inputWidth % 2 === 0) {
                inputWidth += 1;
            }
            if (inputHeight % 2 === 0) {
                inputHeight += 1;
            }

            // Set the larger value as height (maintaining previous logic)
            if (inputWidth > inputHeight) {
                MAZE_WIDTH = inputHeight;
                MAZE_HEIGHT = inputWidth;
            } else {
                MAZE_WIDTH = inputWidth;
                MAZE_HEIGHT = inputHeight;
            }

            startScreenModal.style.display = 'none';
            mainLayout.style.display = 'flex'; // Show mainLayout
            initGame(); // Start game with new dimensions
        });

        // Function to start continuous movement (for mouse/touch)
        function startContinuousMove(direction) {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex') return; // Prevent movement if any modal is active
            if (moveIntervals[direction]) return; // Prevent duplicate execution if already moving

            const moveMap = {
                'up': () => movePlayer(0, -1),
                'down': () => movePlayer(0, 1),
                'left': () => movePlayer(-1, 0),
                'right': () => movePlayer(1, 0)
            };

            // Move once immediately on mouse down
            moveMap[direction]();

            // Start continuous movement (150ms interval for slower speed)
            moveIntervals[direction] = setInterval(moveMap[direction], 150); // Adjusted speed here
        }

        function stopContinuousMove(direction) {
            if (moveIntervals[direction]) {
                clearInterval(moveIntervals[direction]);
                delete moveIntervals[direction];
            }
        }

        // Keyboard input event listener
        document.addEventListener('keydown', (e) => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex') return; // Prevent movement if game won or modal is active

            // Handle rollback keys
            if (['1', '2', '3', '4'].includes(e.key)) {
                saveOrLoadPosition(e.key);
                return; // Prevent default action for number keys
            }

            // Handle Q button (NEW)
            if ((e.key === 'q' || e.key === 'Q') && !qButtonUsed) {
                qButtonUsed = true;
                qButton.disabled = true; // Disable the button
                qButton.classList.add('disabled'); // Add disabled style
                playQButtonSound();
                player.x = startPos.x;
                player.y = startPos.y;
                playerPath = [{ x: player.x, y: player.y }];
                drawMaze();
                showMessage("Q 버튼은 게임당 1회만 사용 가능합니다. 시작 지점으로 돌아왔습니다.");
                return;
            }

            // Handle E button
            if ((e.key === 'e' || e.key === 'E') && !eButtonUsed) {
                eButtonUsed = true;
                eButton.disabled = true; // Disable the button
                eButton.classList.add('disabled'); // Add disabled style
                playEButtonSound();
                showMessage(`최근 이동 경로 ${MAX_PLAYER_PATH}칸을 표시합니다. 0.5초마다 사라집니다.`); // Updated message
                drawMaze(); // Redraw to show path immediately

                // Start clearing path
                eButtonClearInterval = setInterval(() => {
                    if (playerPath.length > 0) {
                        playerPath.shift(); // Remove oldest path segment
                        drawMaze(); // Redraw to reflect removal
                    } else {
                        clearInterval(eButtonClearInterval);
                        eButtonClearInterval = null;
                        showMessage("이동 경로 표시가 완료되었습니다.", 'info');
                    }
                }, 500); // Clear every 0.5 seconds

                return;
            }


            // Handle movement keys (Arrow keys and WASD)
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePlayer(1, 0);
                    break;
            }
        });

        // Mouse click event listeners (directional buttons)
        document.getElementById('up').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('up'); });
        document.getElementById('down').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('down'); });
        document.getElementById('left').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('left'); });
        document.getElementById('right').addEventListener('mousedown', (e) => { e.preventDefault(); startContinuousMove('right'); });

        // Q button click event listener (NEW)
        qButton.addEventListener('click', () => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex' || qButtonUsed) return;
            qButtonUsed = true;
            qButton.disabled = true;
            qButton.classList.add('disabled');
            playQButtonSound();
            player.x = startPos.x;
            player.y = startPos.y;
            playerPath = [{ x: player.x, y: player.y }];
            drawMaze();
            showMessage("Q 버튼은 게임당 1회만 사용 가능합니다. 시작 지점으로 돌아왔습니다.");
        });

        eButton.addEventListener('click', () => {
            if (gameWon || startScreenModal.style.display === 'flex' || helpModal.style.display === 'flex' || screenshotModal.style.display === 'flex' || eButtonUsed) return;
            eButtonUsed = true;
            eButton.disabled = true; // Disable the button
            eButton.classList.add('disabled'); // Add disabled style
            playEButtonSound();
            showMessage(`최근 이동 경로 ${MAX_PLAYER_PATH}칸을 표시합니다. 0.5초마다 사라집니다.`); // Updated message
            drawMaze(); // Redraw to show path immediately

            // Start clearing path
            eButtonClearInterval = setInterval(() => {
                if (playerPath.length > 0) {
                    playerPath.shift(); // Remove oldest path segment
                    drawMaze(); // Redraw to reflect removal
                } else {
                    clearInterval(eButtonClearInterval);
                    eButtonClearInterval = null;
                    showMessage("이동 경로 표시가 완료되었습니다.", 'info');
                }
            }, 500); // Clear every 0.5 seconds
        });

        // Share button click event listener
        shareButton.addEventListener('click', takeScreenshot);

        // Screenshot modal close button event listener
        closeScreenshotModalButton.addEventListener('click', () => {
            screenshotModal.style.display = 'none';
        });


        // Stop continuous movement when mouse button is released or leaves button area
        document.addEventListener('mouseup', () => {
            for (const dir in moveIntervals) {
                stopContinuousMove(dir);
            }
        });

        document.getElementById('up').addEventListener('mouseleave', () => stopContinuousMove('up'));
        document.getElementById('down').addEventListener('mouseleave', () => stopContinuousMove('down'));
        document.getElementById('left').addEventListener('mouseleave', () => stopContinuousMove('left'));
        document.getElementById('right').addEventListener('mouseleave', () => stopContinuousMove('right'));
        qButton.addEventListener('mouseleave', () => stopContinuousMove('q')); // Ensure Q button doesn't trigger continuous move
        eButton.addEventListener('mouseleave', () => stopContinuousMove('e')); // Ensure E button doesn't trigger continuous move


        // Mouse click event listeners (rollback) - Left group
        rollback1_left.addEventListener('click', () => saveOrLoadPosition('1'));
        rollback2_left.addEventListener('click', () => saveOrLoadPosition('2'));
        rollback3_left.addEventListener('click', () => saveOrLoadPosition('3'));
        rollback4_left.addEventListener('click', () => saveOrLoadPosition('4'));

        // Mouse click event listeners (rollback) - Right group
        rollback1_right.addEventListener('click', () => saveOrLoadPosition('1'));
        rollback2_right.addEventListener('click', () => saveOrLoadPosition('2'));
        rollback3_right.addEventListener('click', () => saveOrLoadPosition('3'));
        rollback4_right.addEventListener('click', () => saveOrLoadPosition('4'));

        // Restart button event listener
        restartButton.addEventListener('click', initGame); // 'Restart' button restarts the game

        // Restart button event listener inside win modal
        winRestartButton.addEventListener('click', () => {
            winModal.style.display = 'none'; // Hide modal
            initGame(); // Restart game
        });

        // Reset size button event listener
        resetSizeButton.addEventListener('click', showStartScreen); // 'Reset Size' button returns to start screen

        // Help button event listener
        helpButton.addEventListener('click', () => {
            helpModal.style.display = 'flex'; // Show help modal
        });

        // Help modal close button event listener
        closeHelpModalButton.addEventListener('click', () => {
            helpModal.style.display = 'none'; // Hide help modal
        });

        // Maze size input validation (odd number and within range)
        function validateMazeSizeInput(event) {
            let value = parseInt(event.target.value);
            const min = parseInt(event.target.min);
            const max = parseInt(event.target.max);

            if (isNaN(value)) {
                event.target.value = event.target.min; // Default to min if not a number
                return;
            }

            // Limit value within min/max range
            value = Math.max(min, Math.min(value, max));

            // If value is even, make it odd (increment by 1 if not max)
            if (value % 2 === 0) {
                if (value < max) {
                    value += 1;
                } else {
                    value -= 1; // If max is even and input is max, make it max-1 (odd)
                }
            }
            event.target.value = value;
        }

        mazeWidthInput.addEventListener('change', validateMazeSizeInput);
        mazeHeightInput.addEventListener('change', validateMazeSizeInput); // Corrected function name

        // Game initialization on window resize (responsive)
        window.addEventListener('resize', () => {
            if (mainLayout.style.display === 'flex') { // Only respond if game is displayed
                initGame();
            }
        });

        // Initial setup: show start screen first and initialize audio
        document.addEventListener('DOMContentLoaded', function() {
            showStartScreen();
            initAudio(); // Initialize audio context
        });
    </script>
</body>
</html>
